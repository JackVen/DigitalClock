
DigitalClock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000102  00800100  00001514  000015a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001514  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000051  00800202  00800202  000016aa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000016aa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000016dc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002a0  00000000  00000000  0000171c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004b68  00000000  00000000  000019bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001159  00000000  00000000  00006524  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001baf  00000000  00000000  0000767d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000694  00000000  00000000  0000922c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000904  00000000  00000000  000098c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001ed4  00000000  00000000  0000a1c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000250  00000000  00000000  0000c098  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 99 00 	jmp	0x132	; 0x132 <__ctors_end>
       4:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       8:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
       c:	0c 94 2d 03 	jmp	0x65a	; 0x65a <__vector_3>
      10:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      14:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      18:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      1c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      20:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      24:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      28:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      2c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      30:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      34:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      38:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      3c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      40:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      44:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      48:	0c 94 f3 02 	jmp	0x5e6	; 0x5e6 <__vector_18>
      4c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      50:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      54:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      58:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      5c:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      60:	0c 94 07 0a 	jmp	0x140e	; 0x140e <__vector_24>
      64:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__bad_interrupt>
      68:	b3 03       	fmuls	r19, r19
      6a:	b7 03       	fmuls	r19, r23
      6c:	bb 03       	fmulsu	r19, r19
      6e:	bf 03       	fmulsu	r19, r23
      70:	c3 03       	fmuls	r20, r19
      72:	c7 03       	fmuls	r20, r23
      74:	cb 03       	fmulsu	r20, r19
      76:	cf 03       	fmulsu	r20, r23
      78:	d3 03       	fmuls	r21, r19
      7a:	d7 03       	fmuls	r21, r23
      7c:	12 04       	cpc	r1, r2
      7e:	16 04       	cpc	r1, r6
      80:	1a 04       	cpc	r1, r10
      82:	1e 04       	cpc	r1, r14
      84:	22 04       	cpc	r2, r2
      86:	26 04       	cpc	r2, r6
      88:	2a 04       	cpc	r2, r10
      8a:	2e 04       	cpc	r2, r14
      8c:	32 04       	cpc	r3, r2
      8e:	36 04       	cpc	r3, r6
      90:	22 0a       	sbc	r2, r18
      92:	6e 0a       	sbc	r6, r30
      94:	6e 0a       	sbc	r6, r30
      96:	6e 0a       	sbc	r6, r30
      98:	6e 0a       	sbc	r6, r30
      9a:	6e 0a       	sbc	r6, r30
      9c:	6e 0a       	sbc	r6, r30
      9e:	6e 0a       	sbc	r6, r30
      a0:	22 0a       	sbc	r2, r18
      a2:	6e 0a       	sbc	r6, r30
      a4:	6e 0a       	sbc	r6, r30
      a6:	6e 0a       	sbc	r6, r30
      a8:	6e 0a       	sbc	r6, r30
      aa:	6e 0a       	sbc	r6, r30
      ac:	6e 0a       	sbc	r6, r30
      ae:	6e 0a       	sbc	r6, r30
      b0:	24 0a       	sbc	r2, r20
      b2:	6e 0a       	sbc	r6, r30
      b4:	6e 0a       	sbc	r6, r30
      b6:	6e 0a       	sbc	r6, r30
      b8:	6e 0a       	sbc	r6, r30
      ba:	6e 0a       	sbc	r6, r30
      bc:	6e 0a       	sbc	r6, r30
      be:	6e 0a       	sbc	r6, r30
      c0:	6e 0a       	sbc	r6, r30
      c2:	6e 0a       	sbc	r6, r30
      c4:	6e 0a       	sbc	r6, r30
      c6:	6e 0a       	sbc	r6, r30
      c8:	6e 0a       	sbc	r6, r30
      ca:	6e 0a       	sbc	r6, r30
      cc:	6e 0a       	sbc	r6, r30
      ce:	6e 0a       	sbc	r6, r30
      d0:	24 0a       	sbc	r2, r20
      d2:	6e 0a       	sbc	r6, r30
      d4:	6e 0a       	sbc	r6, r30
      d6:	6e 0a       	sbc	r6, r30
      d8:	6e 0a       	sbc	r6, r30
      da:	6e 0a       	sbc	r6, r30
      dc:	6e 0a       	sbc	r6, r30
      de:	6e 0a       	sbc	r6, r30
      e0:	6e 0a       	sbc	r6, r30
      e2:	6e 0a       	sbc	r6, r30
      e4:	6e 0a       	sbc	r6, r30
      e6:	6e 0a       	sbc	r6, r30
      e8:	6e 0a       	sbc	r6, r30
      ea:	6e 0a       	sbc	r6, r30
      ec:	6e 0a       	sbc	r6, r30
      ee:	6e 0a       	sbc	r6, r30
      f0:	6a 0a       	sbc	r6, r26
      f2:	6e 0a       	sbc	r6, r30
      f4:	6e 0a       	sbc	r6, r30
      f6:	6e 0a       	sbc	r6, r30
      f8:	6e 0a       	sbc	r6, r30
      fa:	6e 0a       	sbc	r6, r30
      fc:	6e 0a       	sbc	r6, r30
      fe:	6e 0a       	sbc	r6, r30
     100:	3f 0a       	sbc	r3, r31
     102:	6e 0a       	sbc	r6, r30
     104:	6e 0a       	sbc	r6, r30
     106:	6e 0a       	sbc	r6, r30
     108:	6e 0a       	sbc	r6, r30
     10a:	6e 0a       	sbc	r6, r30
     10c:	6e 0a       	sbc	r6, r30
     10e:	6e 0a       	sbc	r6, r30
     110:	6e 0a       	sbc	r6, r30
     112:	6e 0a       	sbc	r6, r30
     114:	6e 0a       	sbc	r6, r30
     116:	6e 0a       	sbc	r6, r30
     118:	6e 0a       	sbc	r6, r30
     11a:	6e 0a       	sbc	r6, r30
     11c:	6e 0a       	sbc	r6, r30
     11e:	6e 0a       	sbc	r6, r30
     120:	3f 0a       	sbc	r3, r31
     122:	6e 0a       	sbc	r6, r30
     124:	6e 0a       	sbc	r6, r30
     126:	6e 0a       	sbc	r6, r30
     128:	6e 0a       	sbc	r6, r30
     12a:	6e 0a       	sbc	r6, r30
     12c:	6e 0a       	sbc	r6, r30
     12e:	6e 0a       	sbc	r6, r30
     130:	5b 0a       	sbc	r5, r27

00000132 <__ctors_end>:
     132:	11 24       	eor	r1, r1
     134:	1f be       	out	0x3f, r1	; 63
     136:	cf ef       	ldi	r28, 0xFF	; 255
     138:	d8 e0       	ldi	r29, 0x08	; 8
     13a:	de bf       	out	0x3e, r29	; 62
     13c:	cd bf       	out	0x3d, r28	; 61

0000013e <__do_copy_data>:
     13e:	12 e0       	ldi	r17, 0x02	; 2
     140:	a0 e0       	ldi	r26, 0x00	; 0
     142:	b1 e0       	ldi	r27, 0x01	; 1
     144:	e4 e1       	ldi	r30, 0x14	; 20
     146:	f5 e1       	ldi	r31, 0x15	; 21
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x10>
     14a:	05 90       	lpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	a2 30       	cpi	r26, 0x02	; 2
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0xc>

00000154 <__do_clear_bss>:
     154:	22 e0       	ldi	r18, 0x02	; 2
     156:	a2 e0       	ldi	r26, 0x02	; 2
     158:	b2 e0       	ldi	r27, 0x02	; 2
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	a3 35       	cpi	r26, 0x53	; 83
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 b5 08 	call	0x116a	; 0x116a <main>
     168:	0c 94 88 0a 	jmp	0x1510	; 0x1510 <_exit>

0000016c <__bad_interrupt>:
     16c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000170 <init_bluetooth>:
	{
		data = data - 48;
	}
	
	return data;
}
     170:	22 98       	cbi	0x04, 2	; 4
     172:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <__data_end>
     176:	08 95       	ret

00000178 <connectingBlueTooth>:

/************************************************************************/
/* Connecting the Bluetooth module function                             */
/************************************************************************/
void connectingBlueTooth(void)
{
     178:	cf 93       	push	r28
     17a:	df 93       	push	r29
	lcd_string_clear();
     17c:	0e 94 88 05 	call	0xb10	; 0xb10 <lcd_string_clear>
	//If the BT module is not connected
	if((PINB & BTPIN) == BT_NOTCONNECTED)
     180:	1a 99       	sbic	0x03, 2	; 3
     182:	2b c0       	rjmp	.+86     	; 0x1da <connectingBlueTooth+0x62>
	{
		
		lcd_setcurstring(LCD_COL3, LCD_ROW1,"Connecting");
     184:	40 e0       	ldi	r20, 0x00	; 0
     186:	51 e0       	ldi	r21, 0x01	; 1
     188:	61 e0       	ldi	r22, 0x01	; 1
     18a:	83 e0       	ldi	r24, 0x03	; 3
     18c:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
		lcd_generatechar(LCD_GC_CHAR0, btchar, LCD_SET_DDADR2, LCD_COL8);
     190:	28 e0       	ldi	r18, 0x08	; 8
     192:	40 ec       	ldi	r20, 0xC0	; 192
     194:	6a ea       	ldi	r22, 0xAA	; 170
     196:	71 e0       	ldi	r23, 0x01	; 1
     198:	80 e0       	ldi	r24, 0x00	; 0
     19a:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
     19e:	c3 e0       	ldi	r28, 0x03	; 3
		
		for (int i = 3; i < 8; i++)
		{
			lcd_setcurstring(i,LCD_ROW2,">");
			lcd_setcurstring(15-i,LCD_ROW2,"<");
     1a0:	df e0       	ldi	r29, 0x0F	; 15
		lcd_setcurstring(LCD_COL3, LCD_ROW1,"Connecting");
		lcd_generatechar(LCD_GC_CHAR0, btchar, LCD_SET_DDADR2, LCD_COL8);
		
		for (int i = 3; i < 8; i++)
		{
			lcd_setcurstring(i,LCD_ROW2,">");
     1a2:	4b e0       	ldi	r20, 0x0B	; 11
     1a4:	51 e0       	ldi	r21, 0x01	; 1
     1a6:	62 e0       	ldi	r22, 0x02	; 2
     1a8:	8c 2f       	mov	r24, r28
     1aa:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
			lcd_setcurstring(15-i,LCD_ROW2,"<");
     1ae:	4d e0       	ldi	r20, 0x0D	; 13
     1b0:	51 e0       	ldi	r21, 0x01	; 1
     1b2:	62 e0       	ldi	r22, 0x02	; 2
     1b4:	8d 2f       	mov	r24, r29
     1b6:	8c 1b       	sub	r24, r28
     1b8:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1bc:	2f ef       	ldi	r18, 0xFF	; 255
     1be:	83 ec       	ldi	r24, 0xC3	; 195
     1c0:	99 e0       	ldi	r25, 0x09	; 9
     1c2:	21 50       	subi	r18, 0x01	; 1
     1c4:	80 40       	sbci	r24, 0x00	; 0
     1c6:	90 40       	sbci	r25, 0x00	; 0
     1c8:	e1 f7       	brne	.-8      	; 0x1c2 <connectingBlueTooth+0x4a>
     1ca:	00 c0       	rjmp	.+0      	; 0x1cc <connectingBlueTooth+0x54>
     1cc:	00 00       	nop
     1ce:	cf 5f       	subi	r28, 0xFF	; 255
	{
		
		lcd_setcurstring(LCD_COL3, LCD_ROW1,"Connecting");
		lcd_generatechar(LCD_GC_CHAR0, btchar, LCD_SET_DDADR2, LCD_COL8);
		
		for (int i = 3; i < 8; i++)
     1d0:	c8 30       	cpi	r28, 0x08	; 8
     1d2:	39 f7       	brne	.-50     	; 0x1a2 <connectingBlueTooth+0x2a>
			lcd_setcurstring(i,LCD_ROW2,">");
			lcd_setcurstring(15-i,LCD_ROW2,"<");
			_delay_ms(200);
			
		}
		connectedflag = FALSE;
     1d4:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <__data_end>
     1d8:	2d c0       	rjmp	.+90     	; 0x234 <connectingBlueTooth+0xbc>
		
	}

	
	//If the BT module is connected and the flag is false
	else if (((PINB & BTPIN) == BT_CONNECTED) && (connectedflag == FALSE) )
     1da:	1a 9b       	sbis	0x03, 2	; 3
     1dc:	2b c0       	rjmp	.+86     	; 0x234 <connectingBlueTooth+0xbc>
     1de:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <__data_end>
     1e2:	81 11       	cpse	r24, r1
     1e4:	27 c0       	rjmp	.+78     	; 0x234 <connectingBlueTooth+0xbc>
	{
		lcd_setcurstring(3,1,"Connected");
     1e6:	4f e0       	ldi	r20, 0x0F	; 15
     1e8:	51 e0       	ldi	r21, 0x01	; 1
     1ea:	61 e0       	ldi	r22, 0x01	; 1
     1ec:	83 e0       	ldi	r24, 0x03	; 3
     1ee:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
		lcd_setcurstring(LCD_COL7,LCD_ROW2,"[");
     1f2:	49 e1       	ldi	r20, 0x19	; 25
     1f4:	51 e0       	ldi	r21, 0x01	; 1
     1f6:	62 e0       	ldi	r22, 0x02	; 2
     1f8:	87 e0       	ldi	r24, 0x07	; 7
     1fa:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
		lcd_setcurstring(LCD_COL9,LCD_ROW2,"]");
     1fe:	4b e1       	ldi	r20, 0x1B	; 27
     200:	51 e0       	ldi	r21, 0x01	; 1
     202:	62 e0       	ldi	r22, 0x02	; 2
     204:	89 e0       	ldi	r24, 0x09	; 9
     206:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
		lcd_generatechar(LCD_GC_CHAR0, btchar, LCD_SET_DDADR2, LCD_COL8);
     20a:	28 e0       	ldi	r18, 0x08	; 8
     20c:	40 ec       	ldi	r20, 0xC0	; 192
     20e:	6a ea       	ldi	r22, 0xAA	; 170
     210:	71 e0       	ldi	r23, 0x01	; 1
     212:	80 e0       	ldi	r24, 0x00	; 0
     214:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
		connectedflag = TRUE;
     218:	81 e0       	ldi	r24, 0x01	; 1
     21a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <__data_end>
     21e:	2f ef       	ldi	r18, 0xFF	; 255
     220:	8d e3       	ldi	r24, 0x3D	; 61
     222:	99 e4       	ldi	r25, 0x49	; 73
     224:	21 50       	subi	r18, 0x01	; 1
     226:	80 40       	sbci	r24, 0x00	; 0
     228:	90 40       	sbci	r25, 0x00	; 0
     22a:	e1 f7       	brne	.-8      	; 0x224 <connectingBlueTooth+0xac>
     22c:	00 c0       	rjmp	.+0      	; 0x22e <connectingBlueTooth+0xb6>
     22e:	00 00       	nop
		_delay_ms(1500);
		lcd_string_clear();					//Clear the LCD
     230:	0e 94 88 05 	call	0xb10	; 0xb10 <lcd_string_clear>
		
	}
		
}
     234:	df 91       	pop	r29
     236:	cf 91       	pop	r28
     238:	08 95       	ret

0000023a <SetTheTime>:

/************************************************************************/
/* Set the time from the phone (hours and minutes)                      */
/************************************************************************/
void SetTheTime(void)
{
     23a:	df 92       	push	r13
     23c:	ef 92       	push	r14
     23e:	ff 92       	push	r15
     240:	0f 93       	push	r16
     242:	1f 93       	push	r17
     244:	cf 93       	push	r28
     246:	df 93       	push	r29
     248:	00 d0       	rcall	.+0      	; 0x24a <SetTheTime+0x10>
     24a:	cd b7       	in	r28, 0x3d	; 61
     24c:	de b7       	in	r29, 0x3e	; 62
	uint8_t min1  = 0;								//...same principle 
	uint8_t min2  = 0;								//......
	uint8_t hourarr[2];								//Store the 2 digits in a array

	//Clear the LCD before printing to it..
	lcd_string_clear();
     24e:	0e 94 88 05 	call	0xb10	; 0xb10 <lcd_string_clear>
	lcd_setcurstring(LCD_COL0, LCD_ROW1, "Hour:");
     252:	4d e1       	ldi	r20, 0x1D	; 29
     254:	51 e0       	ldi	r21, 0x01	; 1
     256:	61 e0       	ldi	r22, 0x01	; 1
     258:	80 e0       	ldi	r24, 0x00	; 0
     25a:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
	lcd_setcurstring(LCD_COL13,LCD_ROW1,"[");
     25e:	49 e1       	ldi	r20, 0x19	; 25
     260:	51 e0       	ldi	r21, 0x01	; 1
     262:	61 e0       	ldi	r22, 0x01	; 1
     264:	8d e0       	ldi	r24, 0x0D	; 13
     266:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
	lcd_setcurstring(LCD_COL15,LCD_ROW1,"]");
     26a:	4b e1       	ldi	r20, 0x1B	; 27
     26c:	51 e0       	ldi	r21, 0x01	; 1
     26e:	61 e0       	ldi	r22, 0x01	; 1
     270:	8f e0       	ldi	r24, 0x0F	; 15
     272:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
	lcd_generatechar(LCD_GC_CHAR0, btchar, LCD_SET_DDADR, LCD_COL14);		//Bluetooth character
     276:	2e e0       	ldi	r18, 0x0E	; 14
     278:	40 e8       	ldi	r20, 0x80	; 128
     27a:	6a ea       	ldi	r22, 0xAA	; 170
     27c:	71 e0       	ldi	r23, 0x01	; 1
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_setcurstring(LCD_COL0, LCD_ROW2, "White btn to set:");
     284:	43 e2       	ldi	r20, 0x23	; 35
     286:	51 e0       	ldi	r21, 0x01	; 1
     288:	62 e0       	ldi	r22, 0x02	; 2
     28a:	80 e0       	ldi	r24, 0x00	; 0
     28c:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
/* Set the time from the phone (hours and minutes)                      */
/************************************************************************/
void SetTheTime(void)
{
	
	uint8_t count = 0;								//Variable count data bytes from usart
     290:	10 e0       	ldi	r17, 0x00	; 0
		else if(count >= DIGITLIMIT)									//Check if we have two digits on the array
		{
			 lcd_setcursor(LCD_COL5, LCD_ROW1);
			 lcd_Data(hourarr[0]);										//Print the digits on LCD
			 lcd_Data(hourarr[1]);
			 hour2 = ascii2dec(hourarr[0])*10;							//Convert the digits..
     292:	0f 2e       	mov	r0, r31
     294:	f6 ef       	ldi	r31, 0xF6	; 246
     296:	ef 2e       	mov	r14, r31
     298:	f0 2d       	mov	r31, r0
			 hour2 += ascii2dec(hourarr[1]);							//.....
			 count = 0;													//Reset the counter
     29a:	f1 2c       	mov	r15, r1
	if (data < 48 || data > 57 )		//If data is out of range return 255 or (-1)
	{
	
		data = 255;
	
	return data;
     29c:	dd 24       	eor	r13, r13
     29e:	da 94       	dec	r13
	lcd_generatechar(LCD_GC_CHAR0, btchar, LCD_SET_DDADR, LCD_COL14);		//Bluetooth character
	lcd_setcurstring(LCD_COL0, LCD_ROW2, "White btn to set:");
	
	
	//while the white button is not pressed and dispclocktemp and dispclock are false loop here (hours)
    while((PIND & WHITEBUTTONMSK) != WHITEBUTTON_NOTPRESSED && (dispclocktemp == FALSE) && (dispclock == FALSE))
     2a0:	58 c0       	rjmp	.+176    	; 0x352 <SetTheTime+0x118>
	{
		if((hour1 = usart_recieve()) != '\0')							//Fetch data from usart (digits)
     2a2:	0e 94 d6 02 	call	0x5ac	; 0x5ac <usart_recieve>
     2a6:	88 23       	and	r24, r24
     2a8:	89 f0       	breq	.+34     	; 0x2cc <SetTheTime+0x92>
		{
			
			hourarr[count++] = hour1;									//Store data
     2aa:	91 e0       	ldi	r25, 0x01	; 1
     2ac:	91 0f       	add	r25, r17
     2ae:	e1 e0       	ldi	r30, 0x01	; 1
     2b0:	f0 e0       	ldi	r31, 0x00	; 0
     2b2:	ec 0f       	add	r30, r28
     2b4:	fd 1f       	adc	r31, r29
     2b6:	e1 0f       	add	r30, r17
     2b8:	f1 1d       	adc	r31, r1
     2ba:	80 83       	st	Z, r24
     2bc:	ef e1       	ldi	r30, 0x1F	; 31
     2be:	fe e4       	ldi	r31, 0x4E	; 78
     2c0:	31 97       	sbiw	r30, 0x01	; 1
     2c2:	f1 f7       	brne	.-4      	; 0x2c0 <SetTheTime+0x86>
     2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <SetTheTime+0x8c>
     2c6:	00 00       	nop
     2c8:	19 2f       	mov	r17, r25
     2ca:	43 c0       	rjmp	.+134    	; 0x352 <SetTheTime+0x118>
			_delay_ms(5);
			
		}
		 
		else if(count >= DIGITLIMIT)									//Check if we have two digits on the array
     2cc:	12 30       	cpi	r17, 0x02	; 2
     2ce:	08 f4       	brcc	.+2      	; 0x2d2 <SetTheTime+0x98>
     2d0:	40 c0       	rjmp	.+128    	; 0x352 <SetTheTime+0x118>
		{
			 lcd_setcursor(LCD_COL5, LCD_ROW1);
     2d2:	61 e0       	ldi	r22, 0x01	; 1
     2d4:	85 e0       	ldi	r24, 0x05	; 5
     2d6:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
			 lcd_Data(hourarr[0]);										//Print the digits on LCD
     2da:	19 81       	ldd	r17, Y+1	; 0x01
     2dc:	81 2f       	mov	r24, r17
     2de:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
			 lcd_Data(hourarr[1]);
     2e2:	0a 81       	ldd	r16, Y+2	; 0x02
     2e4:	80 2f       	mov	r24, r16
     2e6:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
/************************************************************************/
uint8_t ascii2dec(uint8_t data)
{
	
		
	if (data < 48 || data > 57 )		//If data is out of range return 255 or (-1)
     2ea:	10 53       	subi	r17, 0x30	; 48
     2ec:	1a 30       	cpi	r17, 0x0A	; 10
     2ee:	08 f0       	brcs	.+2      	; 0x2f2 <SetTheTime+0xb8>
     2f0:	d6 c0       	rjmp	.+428    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
		else if(count >= DIGITLIMIT)									//Check if we have two digits on the array
		{
			 lcd_setcursor(LCD_COL5, LCD_ROW1);
			 lcd_Data(hourarr[0]);										//Print the digits on LCD
			 lcd_Data(hourarr[1]);
			 hour2 = ascii2dec(hourarr[0])*10;							//Convert the digits..
     2f2:	11 0f       	add	r17, r17
     2f4:	81 2f       	mov	r24, r17
     2f6:	88 0f       	add	r24, r24
     2f8:	88 0f       	add	r24, r24
     2fa:	18 0f       	add	r17, r24
/************************************************************************/
uint8_t ascii2dec(uint8_t data)
{
	
		
	if (data < 48 || data > 57 )		//If data is out of range return 255 or (-1)
     2fc:	80 ed       	ldi	r24, 0xD0	; 208
     2fe:	80 0f       	add	r24, r16
     300:	8a 30       	cpi	r24, 0x0A	; 10
     302:	08 f0       	brcs	.+2      	; 0x306 <SetTheTime+0xcc>
	{
	
		data = 255;
	
	return data;
     304:	8d 2d       	mov	r24, r13
		{
			 lcd_setcursor(LCD_COL5, LCD_ROW1);
			 lcd_Data(hourarr[0]);										//Print the digits on LCD
			 lcd_Data(hourarr[1]);
			 hour2 = ascii2dec(hourarr[0])*10;							//Convert the digits..
			 hour2 += ascii2dec(hourarr[1]);							//.....
     306:	81 0f       	add	r24, r17
			 count = 0;													//Reset the counter
			
			 if (hour2 > HOURLIMIT)										//Check if hour is bigger than 23
     308:	88 31       	cpi	r24, 0x18	; 24
     30a:	00 f1       	brcs	.+64     	; 0x34c <SetTheTime+0x112>
			 {
				 lcd_setcurstring(LCD_COL5, LCD_ROW1, "00-23");			//If bigger print the desire range
     30c:	45 e3       	ldi	r20, 0x35	; 53
     30e:	51 e0       	ldi	r21, 0x01	; 1
     310:	61 e0       	ldi	r22, 0x01	; 1
     312:	85 e0       	ldi	r24, 0x05	; 5
     314:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
     318:	ff ef       	ldi	r31, 0xFF	; 255
     31a:	2b e4       	ldi	r18, 0x4B	; 75
     31c:	8d e1       	ldi	r24, 0x1D	; 29
     31e:	f1 50       	subi	r31, 0x01	; 1
     320:	20 40       	sbci	r18, 0x00	; 0
     322:	80 40       	sbci	r24, 0x00	; 0
     324:	e1 f7       	brne	.-8      	; 0x31e <SetTheTime+0xe4>
     326:	00 c0       	rjmp	.+0      	; 0x328 <SetTheTime+0xee>
     328:	00 00       	nop
				 _delay_ms(600);
				 lcd_setcurstring(LCD_COL5, LCD_ROW1, "       ");
     32a:	43 e8       	ldi	r20, 0x83	; 131
     32c:	51 e0       	ldi	r21, 0x01	; 1
     32e:	61 e0       	ldi	r22, 0x01	; 1
     330:	85 e0       	ldi	r24, 0x05	; 5
     332:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
     336:	9f ef       	ldi	r25, 0xFF	; 255
     338:	eb e4       	ldi	r30, 0x4B	; 75
     33a:	fd e1       	ldi	r31, 0x1D	; 29
     33c:	91 50       	subi	r25, 0x01	; 1
     33e:	e0 40       	sbci	r30, 0x00	; 0
     340:	f0 40       	sbci	r31, 0x00	; 0
     342:	e1 f7       	brne	.-8      	; 0x33c <SetTheTime+0x102>
     344:	00 c0       	rjmp	.+0      	; 0x346 <SetTheTime+0x10c>
     346:	00 00       	nop
			 lcd_setcursor(LCD_COL5, LCD_ROW1);
			 lcd_Data(hourarr[0]);										//Print the digits on LCD
			 lcd_Data(hourarr[1]);
			 hour2 = ascii2dec(hourarr[0])*10;							//Convert the digits..
			 hour2 += ascii2dec(hourarr[1]);							//.....
			 count = 0;													//Reset the counter
     348:	1f 2d       	mov	r17, r15
     34a:	03 c0       	rjmp	.+6      	; 0x352 <SetTheTime+0x118>
			 }
			
			 
			 else
			 {
				 hour = hour2;											//If everything is OK then store hour2 in hour
     34c:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <hour>
			 lcd_setcursor(LCD_COL5, LCD_ROW1);
			 lcd_Data(hourarr[0]);										//Print the digits on LCD
			 lcd_Data(hourarr[1]);
			 hour2 = ascii2dec(hourarr[0])*10;							//Convert the digits..
			 hour2 += ascii2dec(hourarr[1]);							//.....
			 count = 0;													//Reset the counter
     350:	1f 2d       	mov	r17, r15
	lcd_generatechar(LCD_GC_CHAR0, btchar, LCD_SET_DDADR, LCD_COL14);		//Bluetooth character
	lcd_setcurstring(LCD_COL0, LCD_ROW2, "White btn to set:");
	
	
	//while the white button is not pressed and dispclocktemp and dispclock are false loop here (hours)
    while((PIND & WHITEBUTTONMSK) != WHITEBUTTON_NOTPRESSED && (dispclocktemp == FALSE) && (dispclock == FALSE))
     352:	4b 99       	sbic	0x09, 3	; 9
     354:	0a c0       	rjmp	.+20     	; 0x36a <SetTheTime+0x130>
     356:	80 91 2d 02 	lds	r24, 0x022D	; 0x80022d <dispclocktemp>
     35a:	81 11       	cpse	r24, r1
     35c:	1c c0       	rjmp	.+56     	; 0x396 <SetTheTime+0x15c>
     35e:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <dispclock>
     362:	88 23       	and	r24, r24
     364:	09 f4       	brne	.+2      	; 0x368 <SetTheTime+0x12e>
     366:	9d cf       	rjmp	.-198    	; 0x2a2 <SetTheTime+0x68>
     368:	16 c0       	rjmp	.+44     	; 0x396 <SetTheTime+0x15c>
		 
		 }
		 		 
	}
	
	if ((dispclocktemp == FALSE) && (dispclock == FALSE))
     36a:	80 91 2d 02 	lds	r24, 0x022D	; 0x80022d <dispclocktemp>
     36e:	81 11       	cpse	r24, r1
     370:	12 c0       	rjmp	.+36     	; 0x396 <SetTheTime+0x15c>
     372:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <dispclock>
     376:	81 11       	cpse	r24, r1
     378:	0e c0       	rjmp	.+28     	; 0x396 <SetTheTime+0x15c>
	{
		lcd_setcurstring(LCD_COL0, LCD_ROW1, "Mins:  ");
     37a:	4b e3       	ldi	r20, 0x3B	; 59
     37c:	51 e0       	ldi	r21, 0x01	; 1
     37e:	61 e0       	ldi	r22, 0x01	; 1
     380:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
     384:	2f ef       	ldi	r18, 0xFF	; 255
     386:	83 ec       	ldi	r24, 0xC3	; 195
     388:	99 e0       	ldi	r25, 0x09	; 9
     38a:	21 50       	subi	r18, 0x01	; 1
     38c:	80 40       	sbci	r24, 0x00	; 0
     38e:	90 40       	sbci	r25, 0x00	; 0
     390:	e1 f7       	brne	.-8      	; 0x38a <SetTheTime+0x150>
     392:	00 c0       	rjmp	.+0      	; 0x394 <SetTheTime+0x15a>
     394:	00 00       	nop
		else if(count >= 2)
		{
			lcd_setcursor(LCD_COL5, LCD_ROW1);
			lcd_Data(hourarr[0]);
			lcd_Data(hourarr[1]);
			min2 = ascii2dec(hourarr[0])*10;
     396:	0f 2e       	mov	r0, r31
     398:	f6 ef       	ldi	r31, 0xF6	; 246
     39a:	ef 2e       	mov	r14, r31
     39c:	f0 2d       	mov	r31, r0
			min2 += ascii2dec(hourarr[1]);
			count = 0;
     39e:	f1 2c       	mov	r15, r1
	if (data < 48 || data > 57 )		//If data is out of range return 255 or (-1)
	{
	
		data = 255;
	
	return data;
     3a0:	dd 24       	eor	r13, r13
     3a2:	da 94       	dec	r13
     3a4:	58 c0       	rjmp	.+176    	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
	////while the white button is not pressed and dispclocktemp and dispclock are false loop here (minutes)
	while((PIND & WHITEBUTTONMSK) != WHITEBUTTON_NOTPRESSED && (dispclocktemp == FALSE) && (dispclock == FALSE))
	{
		
		
		if((min1 = usart_recieve()) != '\0')
     3a6:	0e 94 d6 02 	call	0x5ac	; 0x5ac <usart_recieve>
     3aa:	88 23       	and	r24, r24
     3ac:	89 f0       	breq	.+34     	; 0x3d0 <SetTheTime+0x196>
		{
			
			hourarr[count++] = min1;
     3ae:	91 e0       	ldi	r25, 0x01	; 1
     3b0:	91 0f       	add	r25, r17
     3b2:	e1 e0       	ldi	r30, 0x01	; 1
     3b4:	f0 e0       	ldi	r31, 0x00	; 0
     3b6:	ec 0f       	add	r30, r28
     3b8:	fd 1f       	adc	r31, r29
     3ba:	e1 0f       	add	r30, r17
     3bc:	f1 1d       	adc	r31, r1
     3be:	80 83       	st	Z, r24
     3c0:	ef e1       	ldi	r30, 0x1F	; 31
     3c2:	fe e4       	ldi	r31, 0x4E	; 78
     3c4:	31 97       	sbiw	r30, 0x01	; 1
     3c6:	f1 f7       	brne	.-4      	; 0x3c4 <SetTheTime+0x18a>
     3c8:	00 c0       	rjmp	.+0      	; 0x3ca <SetTheTime+0x190>
     3ca:	00 00       	nop
     3cc:	19 2f       	mov	r17, r25
     3ce:	43 c0       	rjmp	.+134    	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
			_delay_ms(5);
			
		}
		
		else if(count >= 2)
     3d0:	12 30       	cpi	r17, 0x02	; 2
     3d2:	08 f4       	brcc	.+2      	; 0x3d6 <SetTheTime+0x19c>
     3d4:	40 c0       	rjmp	.+128    	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
		{
			lcd_setcursor(LCD_COL5, LCD_ROW1);
     3d6:	61 e0       	ldi	r22, 0x01	; 1
     3d8:	85 e0       	ldi	r24, 0x05	; 5
     3da:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
			lcd_Data(hourarr[0]);
     3de:	19 81       	ldd	r17, Y+1	; 0x01
     3e0:	81 2f       	mov	r24, r17
     3e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
			lcd_Data(hourarr[1]);
     3e6:	0a 81       	ldd	r16, Y+2	; 0x02
     3e8:	80 2f       	mov	r24, r16
     3ea:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
/************************************************************************/
uint8_t ascii2dec(uint8_t data)
{
	
		
	if (data < 48 || data > 57 )		//If data is out of range return 255 or (-1)
     3ee:	10 53       	subi	r17, 0x30	; 48
     3f0:	1a 30       	cpi	r17, 0x0A	; 10
     3f2:	08 f0       	brcs	.+2      	; 0x3f6 <SetTheTime+0x1bc>
     3f4:	5b c0       	rjmp	.+182    	; 0x4ac <__LOCK_REGION_LENGTH__+0xac>
		else if(count >= 2)
		{
			lcd_setcursor(LCD_COL5, LCD_ROW1);
			lcd_Data(hourarr[0]);
			lcd_Data(hourarr[1]);
			min2 = ascii2dec(hourarr[0])*10;
     3f6:	11 0f       	add	r17, r17
     3f8:	81 2f       	mov	r24, r17
     3fa:	88 0f       	add	r24, r24
     3fc:	88 0f       	add	r24, r24
     3fe:	18 0f       	add	r17, r24
/************************************************************************/
uint8_t ascii2dec(uint8_t data)
{
	
		
	if (data < 48 || data > 57 )		//If data is out of range return 255 or (-1)
     400:	80 ed       	ldi	r24, 0xD0	; 208
     402:	80 0f       	add	r24, r16
     404:	8a 30       	cpi	r24, 0x0A	; 10
     406:	08 f0       	brcs	.+2      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
	{
	
		data = 255;
	
	return data;
     408:	8d 2d       	mov	r24, r13
		{
			lcd_setcursor(LCD_COL5, LCD_ROW1);
			lcd_Data(hourarr[0]);
			lcd_Data(hourarr[1]);
			min2 = ascii2dec(hourarr[0])*10;
			min2 += ascii2dec(hourarr[1]);
     40a:	81 0f       	add	r24, r17
			count = 0;
			
			if (min2 > 59)
     40c:	8c 33       	cpi	r24, 0x3C	; 60
     40e:	00 f1       	brcs	.+64     	; 0x450 <__LOCK_REGION_LENGTH__+0x50>
			{
				lcd_setcurstring(LCD_COL5, LCD_ROW1, "00-59");
     410:	43 e4       	ldi	r20, 0x43	; 67
     412:	51 e0       	ldi	r21, 0x01	; 1
     414:	61 e0       	ldi	r22, 0x01	; 1
     416:	85 e0       	ldi	r24, 0x05	; 5
     418:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
     41c:	ff ef       	ldi	r31, 0xFF	; 255
     41e:	2b e4       	ldi	r18, 0x4B	; 75
     420:	8d e1       	ldi	r24, 0x1D	; 29
     422:	f1 50       	subi	r31, 0x01	; 1
     424:	20 40       	sbci	r18, 0x00	; 0
     426:	80 40       	sbci	r24, 0x00	; 0
     428:	e1 f7       	brne	.-8      	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
     42a:	00 c0       	rjmp	.+0      	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
     42c:	00 00       	nop
				_delay_ms(600);
				lcd_setcurstring(LCD_COL5, LCD_ROW1, "       ");
     42e:	43 e8       	ldi	r20, 0x83	; 131
     430:	51 e0       	ldi	r21, 0x01	; 1
     432:	61 e0       	ldi	r22, 0x01	; 1
     434:	85 e0       	ldi	r24, 0x05	; 5
     436:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
     43a:	9f ef       	ldi	r25, 0xFF	; 255
     43c:	eb e4       	ldi	r30, 0x4B	; 75
     43e:	fd e1       	ldi	r31, 0x1D	; 29
     440:	91 50       	subi	r25, 0x01	; 1
     442:	e0 40       	sbci	r30, 0x00	; 0
     444:	f0 40       	sbci	r31, 0x00	; 0
     446:	e1 f7       	brne	.-8      	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
     448:	00 c0       	rjmp	.+0      	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
     44a:	00 00       	nop
			lcd_setcursor(LCD_COL5, LCD_ROW1);
			lcd_Data(hourarr[0]);
			lcd_Data(hourarr[1]);
			min2 = ascii2dec(hourarr[0])*10;
			min2 += ascii2dec(hourarr[1]);
			count = 0;
     44c:	1f 2d       	mov	r17, r15
     44e:	03 c0       	rjmp	.+6      	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
			}
			
			
			else
			{
				min = min2;
     450:	80 93 2e 02 	sts	0x022E, r24	; 0x80022e <min>
			lcd_setcursor(LCD_COL5, LCD_ROW1);
			lcd_Data(hourarr[0]);
			lcd_Data(hourarr[1]);
			min2 = ascii2dec(hourarr[0])*10;
			min2 += ascii2dec(hourarr[1]);
			count = 0;
     454:	1f 2d       	mov	r17, r15
		_delay_ms(200);
			
	}

	////while the white button is not pressed and dispclocktemp and dispclock are false loop here (minutes)
	while((PIND & WHITEBUTTONMSK) != WHITEBUTTON_NOTPRESSED && (dispclocktemp == FALSE) && (dispclock == FALSE))
     456:	4b 99       	sbic	0x09, 3	; 9
     458:	0a c0       	rjmp	.+20     	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
     45a:	80 91 2d 02 	lds	r24, 0x022D	; 0x80022d <dispclocktemp>
     45e:	81 11       	cpse	r24, r1
     460:	1b c0       	rjmp	.+54     	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
     462:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <dispclock>
     466:	88 23       	and	r24, r24
     468:	09 f4       	brne	.+2      	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
     46a:	9d cf       	rjmp	.-198    	; 0x3a6 <SetTheTime+0x16c>
     46c:	15 c0       	rjmp	.+42     	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
			
		}
		
	}
	
	if ((dispclocktemp == FALSE) && (dispclock == FALSE))
     46e:	80 91 2d 02 	lds	r24, 0x022D	; 0x80022d <dispclocktemp>
     472:	81 11       	cpse	r24, r1
     474:	11 c0       	rjmp	.+34     	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
     476:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <dispclock>
     47a:	81 11       	cpse	r24, r1
     47c:	0d c0       	rjmp	.+26     	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
	{
		rtc_set_time(0, min,hour);
     47e:	40 91 1e 02 	lds	r20, 0x021E	; 0x80021e <hour>
     482:	60 91 2e 02 	lds	r22, 0x022E	; 0x80022e <min>
     486:	0e 94 1b 09 	call	0x1236	; 0x1236 <rtc_set_time>
		dispbluetooth=FALSE;
     48a:	10 92 2b 02 	sts	0x022B, r1	; 0x80022b <dispbluetooth>
		dispclocktemp=TRUE;
     48e:	81 e0       	ldi	r24, 0x01	; 1
     490:	80 93 2d 02 	sts	0x022D, r24	; 0x80022d <dispclocktemp>
		dispclock=FALSE;
     494:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <dispclock>
		
	}
	lcd_string_clear();
     498:	0e 94 88 05 	call	0xb10	; 0xb10 <lcd_string_clear>
}
     49c:	0e c0       	rjmp	.+28     	; 0x4ba <__LOCK_REGION_LENGTH__+0xba>
/************************************************************************/
uint8_t ascii2dec(uint8_t data)
{
	
		
	if (data < 48 || data > 57 )		//If data is out of range return 255 or (-1)
     49e:	80 ed       	ldi	r24, 0xD0	; 208
     4a0:	80 0f       	add	r24, r16
     4a2:	8a 30       	cpi	r24, 0x0A	; 10
     4a4:	08 f0       	brcs	.+2      	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
     4a6:	32 cf       	rjmp	.-412    	; 0x30c <SetTheTime+0xd2>
		else if(count >= DIGITLIMIT)									//Check if we have two digits on the array
		{
			 lcd_setcursor(LCD_COL5, LCD_ROW1);
			 lcd_Data(hourarr[0]);										//Print the digits on LCD
			 lcd_Data(hourarr[1]);
			 hour2 = ascii2dec(hourarr[0])*10;							//Convert the digits..
     4a8:	1e 2d       	mov	r17, r14
     4aa:	2d cf       	rjmp	.-422    	; 0x306 <SetTheTime+0xcc>
/************************************************************************/
uint8_t ascii2dec(uint8_t data)
{
	
		
	if (data < 48 || data > 57 )		//If data is out of range return 255 or (-1)
     4ac:	80 ed       	ldi	r24, 0xD0	; 208
     4ae:	80 0f       	add	r24, r16
     4b0:	8a 30       	cpi	r24, 0x0A	; 10
     4b2:	08 f0       	brcs	.+2      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
     4b4:	ad cf       	rjmp	.-166    	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
		else if(count >= 2)
		{
			lcd_setcursor(LCD_COL5, LCD_ROW1);
			lcd_Data(hourarr[0]);
			lcd_Data(hourarr[1]);
			min2 = ascii2dec(hourarr[0])*10;
     4b6:	1e 2d       	mov	r17, r14
     4b8:	a8 cf       	rjmp	.-176    	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
		dispclocktemp=TRUE;
		dispclock=FALSE;
		
	}
	lcd_string_clear();
}
     4ba:	0f 90       	pop	r0
     4bc:	0f 90       	pop	r0
     4be:	df 91       	pop	r29
     4c0:	cf 91       	pop	r28
     4c2:	1f 91       	pop	r17
     4c4:	0f 91       	pop	r16
     4c6:	ff 90       	pop	r15
     4c8:	ef 90       	pop	r14
     4ca:	df 90       	pop	r13
     4cc:	08 95       	ret

000004ce <bluetoothMenu>:



void bluetoothMenu(uint8_t selecdata)
{
     4ce:	cf 93       	push	r28
     4d0:	c8 2f       	mov	r28, r24

	
	lcd_setcurstring(LCD_COL0,LCD_ROW1,"Select:");
     4d2:	49 e4       	ldi	r20, 0x49	; 73
     4d4:	51 e0       	ldi	r21, 0x01	; 1
     4d6:	61 e0       	ldi	r22, 0x01	; 1
     4d8:	80 e0       	ldi	r24, 0x00	; 0
     4da:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
	lcd_setcurstring(LCD_COL13,LCD_ROW1,"[");
     4de:	49 e1       	ldi	r20, 0x19	; 25
     4e0:	51 e0       	ldi	r21, 0x01	; 1
     4e2:	61 e0       	ldi	r22, 0x01	; 1
     4e4:	8d e0       	ldi	r24, 0x0D	; 13
     4e6:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
	lcd_setcurstring(LCD_COL15,LCD_ROW1,"]");
     4ea:	4b e1       	ldi	r20, 0x1B	; 27
     4ec:	51 e0       	ldi	r21, 0x01	; 1
     4ee:	61 e0       	ldi	r22, 0x01	; 1
     4f0:	8f e0       	ldi	r24, 0x0F	; 15
     4f2:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
	lcd_generatechar(LCD_GC_CHAR0, btchar, LCD_SET_DDADR, LCD_COL14);
     4f6:	2e e0       	ldi	r18, 0x0E	; 14
     4f8:	40 e8       	ldi	r20, 0x80	; 128
     4fa:	6a ea       	ldi	r22, 0xAA	; 170
     4fc:	71 e0       	ldi	r23, 0x01	; 1
     4fe:	80 e0       	ldi	r24, 0x00	; 0
     500:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	
	if (selecdata == '\0')
     504:	c1 11       	cpse	r28, r1
     506:	1f c0       	rjmp	.+62     	; 0x546 <bluetoothMenu+0x78>
	{
		lcd_setcurstring(LCD_COL0, LCD_ROW2, "1:Set the time");
     508:	41 e5       	ldi	r20, 0x51	; 81
     50a:	51 e0       	ldi	r21, 0x01	; 1
     50c:	62 e0       	ldi	r22, 0x02	; 2
     50e:	80 e0       	ldi	r24, 0x00	; 0
     510:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
     514:	2f ef       	ldi	r18, 0xFF	; 255
     516:	89 e6       	ldi	r24, 0x69	; 105
     518:	98 e1       	ldi	r25, 0x18	; 24
     51a:	21 50       	subi	r18, 0x01	; 1
     51c:	80 40       	sbci	r24, 0x00	; 0
     51e:	90 40       	sbci	r25, 0x00	; 0
     520:	e1 f7       	brne	.-8      	; 0x51a <bluetoothMenu+0x4c>
     522:	00 c0       	rjmp	.+0      	; 0x524 <bluetoothMenu+0x56>
     524:	00 00       	nop
		_delay_ms(500);
		lcd_setcurstring(LCD_COL0, LCD_ROW2, "2:Exit        ");
     526:	40 e6       	ldi	r20, 0x60	; 96
     528:	51 e0       	ldi	r21, 0x01	; 1
     52a:	62 e0       	ldi	r22, 0x02	; 2
     52c:	80 e0       	ldi	r24, 0x00	; 0
     52e:	0e 94 c2 05 	call	0xb84	; 0xb84 <lcd_setcurstring>
     532:	2f ef       	ldi	r18, 0xFF	; 255
     534:	89 e6       	ldi	r24, 0x69	; 105
     536:	98 e1       	ldi	r25, 0x18	; 24
     538:	21 50       	subi	r18, 0x01	; 1
     53a:	80 40       	sbci	r24, 0x00	; 0
     53c:	90 40       	sbci	r25, 0x00	; 0
     53e:	e1 f7       	brne	.-8      	; 0x538 <bluetoothMenu+0x6a>
     540:	00 c0       	rjmp	.+0      	; 0x542 <bluetoothMenu+0x74>
     542:	00 00       	nop
     544:	25 c0       	rjmp	.+74     	; 0x590 <bluetoothMenu+0xc2>
		
	}
	
	else
	{
		lcd_setcursor(LCD_COL7, LCD_ROW1);
     546:	61 e0       	ldi	r22, 0x01	; 1
     548:	87 e0       	ldi	r24, 0x07	; 7
     54a:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_Data(selecdata);
     54e:	8c 2f       	mov	r24, r28
     550:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
     554:	2f ef       	ldi	r18, 0xFF	; 255
     556:	89 e6       	ldi	r24, 0x69	; 105
     558:	98 e1       	ldi	r25, 0x18	; 24
     55a:	21 50       	subi	r18, 0x01	; 1
     55c:	80 40       	sbci	r24, 0x00	; 0
     55e:	90 40       	sbci	r25, 0x00	; 0
     560:	e1 f7       	brne	.-8      	; 0x55a <bluetoothMenu+0x8c>
     562:	00 c0       	rjmp	.+0      	; 0x564 <bluetoothMenu+0x96>
     564:	00 00       	nop
/************************************************************************/
uint8_t ascii2dec(uint8_t data)
{
	
		
	if (data < 48 || data > 57 )		//If data is out of range return 255 or (-1)
     566:	c0 53       	subi	r28, 0x30	; 48
     568:	ca 30       	cpi	r28, 0x0A	; 10
     56a:	70 f4       	brcc	.+28     	; 0x588 <bluetoothMenu+0xba>
		lcd_setcursor(LCD_COL7, LCD_ROW1);
		lcd_Data(selecdata);
		_delay_ms(500);
		selecdata = ascii2dec(selecdata);
		
		switch(selecdata)
     56c:	c1 30       	cpi	r28, 0x01	; 1
     56e:	19 f0       	breq	.+6      	; 0x576 <bluetoothMenu+0xa8>
     570:	c2 30       	cpi	r28, 0x02	; 2
     572:	19 f0       	breq	.+6      	; 0x57a <bluetoothMenu+0xac>
     574:	09 c0       	rjmp	.+18     	; 0x588 <bluetoothMenu+0xba>
		{
			case 1:
			
			SetTheTime();
     576:	0e 94 1d 01 	call	0x23a	; 0x23a <SetTheTime>
			
			case 2:
			
			dispbluetooth = FALSE;
     57a:	10 92 2b 02 	sts	0x022B, r1	; 0x80022b <dispbluetooth>
			dispclocktemp = TRUE; 
     57e:	81 e0       	ldi	r24, 0x01	; 1
     580:	80 93 2d 02 	sts	0x022D, r24	; 0x80022d <dispclocktemp>
			dispclock     = FALSE;
     584:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <dispclock>
			
			default:
			
			lcd_string("No data");
     588:	8f e6       	ldi	r24, 0x6F	; 111
     58a:	91 e0       	ldi	r25, 0x01	; 1
     58c:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
	
	

		
	
     590:	cf 91       	pop	r28
     592:	08 95       	ret

00000594 <usart_Init>:
		while(!(UCSR0A & (1 << UDRE0)));
		UDR0 = *data++;
	}
	
	
 }
     594:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     598:	87 e6       	ldi	r24, 0x67	; 103
     59a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     59e:	88 e9       	ldi	r24, 0x98	; 152
     5a0:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     5a4:	86 e0       	ldi	r24, 0x06	; 6
     5a6:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
     5aa:	08 95       	ret

000005ac <usart_recieve>:
 unsigned char usart_recieve(void)
 {
	
	char datachar = 0;
	
	if (usartindexpnt > 0)
     5ac:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <usartindexpnt>
     5b0:	88 23       	and	r24, r24
     5b2:	b9 f0       	breq	.+46     	; 0x5e2 <usart_recieve+0x36>
	{
		 
		 for(int i = 0; i < usartindexpnt; i++)
     5b4:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <usartindexpnt>
     5b8:	88 23       	and	r24, r24
     5ba:	79 f0       	breq	.+30     	; 0x5da <usart_recieve+0x2e>
     5bc:	20 e0       	ldi	r18, 0x00	; 0
     5be:	30 e0       	ldi	r19, 0x00	; 0
		 {
			 
			 datachar = usart_Rxbuf[i];
     5c0:	f9 01       	movw	r30, r18
     5c2:	e1 5e       	subi	r30, 0xE1	; 225
     5c4:	fd 4f       	sbci	r31, 0xFD	; 253
     5c6:	80 81       	ld	r24, Z
	char datachar = 0;
	
	if (usartindexpnt > 0)
	{
		 
		 for(int i = 0; i < usartindexpnt; i++)
     5c8:	2f 5f       	subi	r18, 0xFF	; 255
     5ca:	3f 4f       	sbci	r19, 0xFF	; 255
     5cc:	40 91 03 02 	lds	r20, 0x0203	; 0x800203 <usartindexpnt>
     5d0:	50 e0       	ldi	r21, 0x00	; 0
     5d2:	24 17       	cp	r18, r20
     5d4:	35 07       	cpc	r19, r21
     5d6:	a4 f3       	brlt	.-24     	; 0x5c0 <usart_recieve+0x14>
     5d8:	01 c0       	rjmp	.+2      	; 0x5dc <usart_recieve+0x30>
     5da:	80 e0       	ldi	r24, 0x00	; 0
			 
			 datachar = usart_Rxbuf[i];
			 
		 }
		
		usartindexpnt = 0;
     5dc:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <usartindexpnt>
     5e0:	08 95       	ret
 }
 
 unsigned char usart_recieve(void)
 {
	
	char datachar = 0;
     5e2:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	

	return datachar;
 }
     5e4:	08 95       	ret

000005e6 <__vector_18>:
 
 
 
 
 ISR(USART_RX_vect)
 {
     5e6:	1f 92       	push	r1
     5e8:	0f 92       	push	r0
     5ea:	0f b6       	in	r0, 0x3f	; 63
     5ec:	0f 92       	push	r0
     5ee:	11 24       	eor	r1, r1
     5f0:	8f 93       	push	r24
     5f2:	ef 93       	push	r30
     5f4:	ff 93       	push	r31
	
	usart_Rxbuf[usartindexpnt++] = UDR0;
     5f6:	e0 91 03 02 	lds	r30, 0x0203	; 0x800203 <usartindexpnt>
     5fa:	81 e0       	ldi	r24, 0x01	; 1
     5fc:	8e 0f       	add	r24, r30
     5fe:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <usartindexpnt>
     602:	f0 e0       	ldi	r31, 0x00	; 0
     604:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     608:	e1 5e       	subi	r30, 0xE1	; 225
     60a:	fd 4f       	sbci	r31, 0xFD	; 253
     60c:	80 83       	st	Z, r24
	
     60e:	ff 91       	pop	r31
     610:	ef 91       	pop	r30
     612:	8f 91       	pop	r24
     614:	0f 90       	pop	r0
     616:	0f be       	out	0x3f, r0	; 63
     618:	0f 90       	pop	r0
     61a:	1f 90       	pop	r1
     61c:	18 95       	reti

0000061e <buttons_Init>:
 /************************************************************************/
 /* Button initialization function										*/                                            
 /************************************************************************/
 void buttons_Init(void)
{
	PCICR  |= PORTBON;								// turn on pin change interrupt control register on PORT B
     61e:	e8 e6       	ldi	r30, 0x68	; 104
     620:	f0 e0       	ldi	r31, 0x00	; 0
     622:	80 81       	ld	r24, Z
     624:	81 60       	ori	r24, 0x01	; 1
     626:	80 83       	st	Z, r24
	PCMSK0 |= GREENCLKBUTTON;						// Mask if Clock button is pressed
     628:	eb e6       	ldi	r30, 0x6B	; 107
     62a:	f0 e0       	ldi	r31, 0x00	; 0
     62c:	80 81       	ld	r24, Z
     62e:	80 61       	ori	r24, 0x10	; 16
     630:	80 83       	st	Z, r24
	PCMSK0 |= REDCLKTEMPBUTTON;						// Mask if Clock temp button is pressed
     632:	80 81       	ld	r24, Z
     634:	80 62       	ori	r24, 0x20	; 32
     636:	80 83       	st	Z, r24
	PCMSK0 |= BLBUTTON;								// Mask if Clock temp button is pressed
     638:	80 81       	ld	r24, Z
     63a:	88 60       	ori	r24, 0x08	; 8
     63c:	80 83       	st	Z, r24
 	DDRD   &= ~(1 << WHITEBUTTON);				   // PIN 3 in PORT D as input White button
     63e:	53 98       	cbi	0x0a, 3	; 10
	PORTD  &= ~(1 << WHITEBUTTON);				   // Start Pin 3 in PORT D as Zero white button
     640:	5b 98       	cbi	0x0b, 3	; 11
	
	
	
	showclockonetime = TRUE;						//One time variable for the clock
     642:	81 e0       	ldi	r24, 0x01	; 1
     644:	80 93 51 02 	sts	0x0251, r24	; 0x800251 <showclockonetime>
	dispclock = FALSE;								//Initialization values...
     648:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <dispclock>
	dispclocktemp = TRUE;							//..first time the system 
     64c:	80 93 2d 02 	sts	0x022D, r24	; 0x80022d <dispclocktemp>
	dispbluetooth = FALSE;							//..in powered on
     650:	10 92 2b 02 	sts	0x022B, r1	; 0x80022b <dispbluetooth>
	debounce = 0;									//debounce variable, when pushing a button.
     654:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <debounce>
     658:	08 95       	ret

0000065a <__vector_3>:

 /************************************************************************/
 /* Interrupt service routine, when detecting a button press			*/
 /************************************************************************/
 ISR(PCINT0_vect)
 {
     65a:	1f 92       	push	r1
     65c:	0f 92       	push	r0
     65e:	0f b6       	in	r0, 0x3f	; 63
     660:	0f 92       	push	r0
     662:	11 24       	eor	r1, r1
     664:	2f 93       	push	r18
     666:	3f 93       	push	r19
     668:	4f 93       	push	r20
     66a:	5f 93       	push	r21
     66c:	6f 93       	push	r22
     66e:	7f 93       	push	r23
     670:	8f 93       	push	r24
     672:	9f 93       	push	r25
     674:	af 93       	push	r26
     676:	bf 93       	push	r27
     678:	ef 93       	push	r30
     67a:	ff 93       	push	r31
	debounce++;													//Count how many times debounce variable is added when entering  to ISR
     67c:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <debounce>
     680:	8f 5f       	subi	r24, 0xFF	; 255
     682:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <debounce>
	
	
	if ((debounce >= DEBOUNCELIM) && (PINB & REDCLKTEMPBUTTON))			//Check if RED clock temp button is pressed and check debounce variable
     686:	88 23       	and	r24, r24
     688:	f1 f1       	breq	.+124    	; 0x706 <__vector_3+0xac>
     68a:	1d 9b       	sbis	0x03, 5	; 3
     68c:	13 c0       	rjmp	.+38     	; 0x6b4 <__vector_3+0x5a>
	{
		if (dispclocktemp == FALSE)							    //..if false clear lcd, due to another button has been pressed
     68e:	80 91 2d 02 	lds	r24, 0x022D	; 0x80022d <dispclocktemp>
     692:	81 11       	cpse	r24, r1
     694:	05 c0       	rjmp	.+10     	; 0x6a0 <__vector_3+0x46>
		{
			lcd_string_clear();
     696:	0e 94 88 05 	call	0xb10	; 0xb10 <lcd_string_clear>
			showclockonetime = TRUE;
     69a:	81 e0       	ldi	r24, 0x01	; 1
     69c:	80 93 51 02 	sts	0x0251, r24	; 0x800251 <showclockonetime>
				
		}
		
		dispclocktemp = TRUE;								    
     6a0:	81 e0       	ldi	r24, 0x01	; 1
     6a2:	80 93 2d 02 	sts	0x022D, r24	; 0x80022d <dispclocktemp>
		dispclock = FALSE;	
     6a6:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <dispclock>
		dispbluetooth = FALSE;
     6aa:	10 92 2b 02 	sts	0x022B, r1	; 0x80022b <dispbluetooth>
		debounce = 0;
     6ae:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <debounce>
     6b2:	29 c0       	rjmp	.+82     	; 0x706 <__vector_3+0xac>
	
		
		
	}
	
	else if ((debounce >= DEBOUNCELIM) && (PINB & GREENCLKBUTTON))		//Check if GREEN clock button is pressed and check debounce variable
     6b4:	1c 9b       	sbis	0x03, 4	; 3
     6b6:	13 c0       	rjmp	.+38     	; 0x6de <__vector_3+0x84>
	{
		if (dispclock == FALSE)									//..if true clear lcd, due to another button has been pressed
     6b8:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <dispclock>
     6bc:	81 11       	cpse	r24, r1
     6be:	05 c0       	rjmp	.+10     	; 0x6ca <__vector_3+0x70>
		{												
			lcd_string_clear();
     6c0:	0e 94 88 05 	call	0xb10	; 0xb10 <lcd_string_clear>
			showclockonetime = TRUE;							//...and set showclocktime variable to true
     6c4:	81 e0       	ldi	r24, 0x01	; 1
     6c6:	80 93 51 02 	sts	0x0251, r24	; 0x800251 <showclockonetime>
		}
		
		dispclocktemp = FALSE;									//if false continue with the same variables due to the same button has been pressed
     6ca:	10 92 2d 02 	sts	0x022D, r1	; 0x80022d <dispclocktemp>
		dispclock = TRUE;
     6ce:	81 e0       	ldi	r24, 0x01	; 1
     6d0:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <dispclock>
		dispbluetooth = FALSE;
     6d4:	10 92 2b 02 	sts	0x022B, r1	; 0x80022b <dispbluetooth>
		debounce = 0;
     6d8:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <debounce>
     6dc:	14 c0       	rjmp	.+40     	; 0x706 <__vector_3+0xac>
	}
	
	else if((debounce >=  DEBOUNCELIM) && (PINB & BLBUTTON))				//Check if blue-tooth button has been pressed*/
     6de:	1b 9b       	sbis	0x03, 3	; 3
     6e0:	12 c0       	rjmp	.+36     	; 0x706 <__vector_3+0xac>
	{
		
		
		if (dispbluetooth == FALSE)
     6e2:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <dispbluetooth>
     6e6:	81 11       	cpse	r24, r1
     6e8:	05 c0       	rjmp	.+10     	; 0x6f4 <__vector_3+0x9a>
		{
			lcd_string_clear();
     6ea:	0e 94 88 05 	call	0xb10	; 0xb10 <lcd_string_clear>
			showclockonetime = TRUE;
     6ee:	81 e0       	ldi	r24, 0x01	; 1
     6f0:	80 93 51 02 	sts	0x0251, r24	; 0x800251 <showclockonetime>
			
		
		}
		
		dispclocktemp = FALSE;
     6f4:	10 92 2d 02 	sts	0x022D, r1	; 0x80022d <dispclocktemp>
		dispclock = FALSE;	
     6f8:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <dispclock>
		dispbluetooth = TRUE;
     6fc:	81 e0       	ldi	r24, 0x01	; 1
     6fe:	80 93 2b 02 	sts	0x022B, r24	; 0x80022b <dispbluetooth>
		debounce = 0;
     702:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <debounce>
		
		
	}
	
	
 }
     706:	ff 91       	pop	r31
     708:	ef 91       	pop	r30
     70a:	bf 91       	pop	r27
     70c:	af 91       	pop	r26
     70e:	9f 91       	pop	r25
     710:	8f 91       	pop	r24
     712:	7f 91       	pop	r23
     714:	6f 91       	pop	r22
     716:	5f 91       	pop	r21
     718:	4f 91       	pop	r20
     71a:	3f 91       	pop	r19
     71c:	2f 91       	pop	r18
     71e:	0f 90       	pop	r0
     720:	0f be       	out	0x3f, r0	; 63
     722:	0f 90       	pop	r0
     724:	1f 90       	pop	r1
     726:	18 95       	reti

00000728 <FirstDigit>:
/* Displays the first digit on the clock  */
/************************************************************************/

void FirstDigit(uint8_t hour1)
{			
	switch(hour1)
     728:	81 30       	cpi	r24, 0x01	; 1
     72a:	41 f0       	breq	.+16     	; 0x73c <FirstDigit+0x14>
     72c:	18 f0       	brcs	.+6      	; 0x734 <FirstDigit+0xc>
     72e:	82 30       	cpi	r24, 0x02	; 2
     730:	49 f0       	breq	.+18     	; 0x744 <FirstDigit+0x1c>
     732:	0c c0       	rjmp	.+24     	; 0x74c <FirstDigit+0x24>
	{
	
	case 0:
		display_zero(LCD_COL0);	
     734:	80 e0       	ldi	r24, 0x00	; 0
     736:	0e 94 a6 07 	call	0xf4c	; 0xf4c <display_zero>
	break;
     73a:	08 95       	ret
	
	case 1:
		display_one(LCD_COL0);
     73c:	80 e0       	ldi	r24, 0x00	; 0
     73e:	0e 94 0c 06 	call	0xc18	; 0xc18 <display_one>
	break;
     742:	08 95       	ret
	
	case 2:
		display_two(LCD_COL0);		
     744:	80 e0       	ldi	r24, 0x00	; 0
     746:	0e 94 38 06 	call	0xc70	; 0xc70 <display_two>
	break;
     74a:	08 95       	ret
	
	default:
		display_zero(LCD_COL0);
     74c:	80 e0       	ldi	r24, 0x00	; 0
     74e:	0e 94 a6 07 	call	0xf4c	; 0xf4c <display_zero>
     752:	08 95       	ret

00000754 <SecondDigit>:
/* Displays the second digit on the clock                                */
/************************************************************************/
void SecondDigit(uint8_t hour2)
{

	switch(hour2)
     754:	90 e0       	ldi	r25, 0x00	; 0
     756:	8a 30       	cpi	r24, 0x0A	; 10
     758:	91 05       	cpc	r25, r1
     75a:	68 f5       	brcc	.+90     	; 0x7b6 <SecondDigit+0x62>
     75c:	fc 01       	movw	r30, r24
     75e:	ec 5c       	subi	r30, 0xCC	; 204
     760:	ff 4f       	sbci	r31, 0xFF	; 255
     762:	0c 94 82 0a 	jmp	0x1504	; 0x1504 <__tablejump2__>
	{

	case 0:
		display_zero(LCD_COL4);
     766:	84 e0       	ldi	r24, 0x04	; 4
     768:	0e 94 a6 07 	call	0xf4c	; 0xf4c <display_zero>
	break;
     76c:	08 95       	ret
	
	case 1:
		display_one(LCD_COL4);
     76e:	84 e0       	ldi	r24, 0x04	; 4
     770:	0e 94 0c 06 	call	0xc18	; 0xc18 <display_one>
	break;
     774:	08 95       	ret
	
	case 2:
		display_two(LCD_COL4);
     776:	84 e0       	ldi	r24, 0x04	; 4
     778:	0e 94 38 06 	call	0xc70	; 0xc70 <display_two>
	break;
     77c:	08 95       	ret
	
	case 3:
		display_three(LCD_COL4);
     77e:	84 e0       	ldi	r24, 0x04	; 4
     780:	0e 94 6e 06 	call	0xcdc	; 0xcdc <display_three>
	break;
     784:	08 95       	ret
	
	case 4:
		display_four(LCD_COL4);
     786:	84 e0       	ldi	r24, 0x04	; 4
     788:	0e 94 a4 06 	call	0xd48	; 0xd48 <display_four>
	break;
     78c:	08 95       	ret
	
	case 5:
		display_five(LCD_COL4);
     78e:	84 e0       	ldi	r24, 0x04	; 4
     790:	0e 94 c6 06 	call	0xd8c	; 0xd8c <display_five>
	break;
     794:	08 95       	ret
	
	case 6:
		display_six(LCD_COL4);
     796:	84 e0       	ldi	r24, 0x04	; 4
     798:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <display_six>
	break;
     79c:	08 95       	ret
	
	case 7:
		display_seven(LCD_COL4);
     79e:	84 e0       	ldi	r24, 0x04	; 4
     7a0:	0e 94 2f 07 	call	0xe5e	; 0xe5e <display_seven>
	break;
     7a4:	08 95       	ret
	
	case 8:
		display_eight(LCD_COL4);
     7a6:	84 e0       	ldi	r24, 0x04	; 4
     7a8:	0e 94 51 07 	call	0xea2	; 0xea2 <display_eight>
	break;
     7ac:	08 95       	ret
	
	case 9:
		display_nine(LCD_COL4);
     7ae:	84 e0       	ldi	r24, 0x04	; 4
     7b0:	0e 94 84 07 	call	0xf08	; 0xf08 <display_nine>
	break;
     7b4:	08 95       	ret
	
	default:
		display_zero(LCD_COL4);
     7b6:	84 e0       	ldi	r24, 0x04	; 4
     7b8:	0e 94 a6 07 	call	0xf4c	; 0xf4c <display_zero>
     7bc:	08 95       	ret

000007be <ThirdDigit>:
/* Displays the third digit on the clock                                */
/************************************************************************/
void ThirdDigit(uint8_t min1)
{
	
	switch(min1)
     7be:	82 30       	cpi	r24, 0x02	; 2
     7c0:	a1 f0       	breq	.+40     	; 0x7ea <ThirdDigit+0x2c>
     7c2:	28 f4       	brcc	.+10     	; 0x7ce <ThirdDigit+0x10>
     7c4:	88 23       	and	r24, r24
     7c6:	49 f0       	breq	.+18     	; 0x7da <ThirdDigit+0x1c>
     7c8:	81 30       	cpi	r24, 0x01	; 1
     7ca:	59 f0       	breq	.+22     	; 0x7e2 <ThirdDigit+0x24>
     7cc:	1e c0       	rjmp	.+60     	; 0x80a <ThirdDigit+0x4c>
     7ce:	84 30       	cpi	r24, 0x04	; 4
     7d0:	a1 f0       	breq	.+40     	; 0x7fa <ThirdDigit+0x3c>
     7d2:	78 f0       	brcs	.+30     	; 0x7f2 <ThirdDigit+0x34>
     7d4:	85 30       	cpi	r24, 0x05	; 5
     7d6:	a9 f0       	breq	.+42     	; 0x802 <ThirdDigit+0x44>
     7d8:	18 c0       	rjmp	.+48     	; 0x80a <ThirdDigit+0x4c>
	{
	
	case 0:
		display_zero(LCD_COL8);
     7da:	88 e0       	ldi	r24, 0x08	; 8
     7dc:	0e 94 a6 07 	call	0xf4c	; 0xf4c <display_zero>
	break;
     7e0:	08 95       	ret
	
	case 1:
		display_one(LCD_COL8);
     7e2:	88 e0       	ldi	r24, 0x08	; 8
     7e4:	0e 94 0c 06 	call	0xc18	; 0xc18 <display_one>
	break;
     7e8:	08 95       	ret
	
	case 2:
		display_two(LCD_COL8);
     7ea:	88 e0       	ldi	r24, 0x08	; 8
     7ec:	0e 94 38 06 	call	0xc70	; 0xc70 <display_two>
	break;
     7f0:	08 95       	ret
	
	case 3:
		display_three(LCD_COL8);
     7f2:	88 e0       	ldi	r24, 0x08	; 8
     7f4:	0e 94 6e 06 	call	0xcdc	; 0xcdc <display_three>
	break;
     7f8:	08 95       	ret
	
	case 4:
		display_four(LCD_COL8);
     7fa:	88 e0       	ldi	r24, 0x08	; 8
     7fc:	0e 94 a4 06 	call	0xd48	; 0xd48 <display_four>
	break;
     800:	08 95       	ret
	
	case 5:
		display_five(LCD_COL8);
     802:	88 e0       	ldi	r24, 0x08	; 8
     804:	0e 94 c6 06 	call	0xd8c	; 0xd8c <display_five>
	break;
     808:	08 95       	ret
	
	default:
		display_zero(LCD_COL8);
     80a:	88 e0       	ldi	r24, 0x08	; 8
     80c:	0e 94 a6 07 	call	0xf4c	; 0xf4c <display_zero>
     810:	08 95       	ret

00000812 <FourthDigit>:
/************************************************************************/
void FourthDigit(uint8_t min2)
{
	
	
	switch(min2)
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	8a 30       	cpi	r24, 0x0A	; 10
     816:	91 05       	cpc	r25, r1
     818:	68 f5       	brcc	.+90     	; 0x874 <FourthDigit+0x62>
     81a:	fc 01       	movw	r30, r24
     81c:	e2 5c       	subi	r30, 0xC2	; 194
     81e:	ff 4f       	sbci	r31, 0xFF	; 255
     820:	0c 94 82 0a 	jmp	0x1504	; 0x1504 <__tablejump2__>
	{
		
	
	case 0:
		display_zero(LCD_COL12);
     824:	8c e0       	ldi	r24, 0x0C	; 12
     826:	0e 94 a6 07 	call	0xf4c	; 0xf4c <display_zero>
	break;
     82a:	08 95       	ret
		
	case 1:
		display_one(LCD_COL12);
     82c:	8c e0       	ldi	r24, 0x0C	; 12
     82e:	0e 94 0c 06 	call	0xc18	; 0xc18 <display_one>
	break;
     832:	08 95       	ret
	
	case 2:
		display_two(LCD_COL12);
     834:	8c e0       	ldi	r24, 0x0C	; 12
     836:	0e 94 38 06 	call	0xc70	; 0xc70 <display_two>
	break;
     83a:	08 95       	ret
	
	case 3:
		display_three(LCD_COL12);
     83c:	8c e0       	ldi	r24, 0x0C	; 12
     83e:	0e 94 6e 06 	call	0xcdc	; 0xcdc <display_three>
	break;
     842:	08 95       	ret
	
	case 4:
		display_four(LCD_COL12);
     844:	8c e0       	ldi	r24, 0x0C	; 12
     846:	0e 94 a4 06 	call	0xd48	; 0xd48 <display_four>
	break;
     84a:	08 95       	ret
	
	case 5:
		display_five(LCD_COL12);
     84c:	8c e0       	ldi	r24, 0x0C	; 12
     84e:	0e 94 c6 06 	call	0xd8c	; 0xd8c <display_five>
	break;
     852:	08 95       	ret
	
	case 6:
		display_six(LCD_COL12);
     854:	8c e0       	ldi	r24, 0x0C	; 12
     856:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <display_six>
	break;
     85a:	08 95       	ret
	
	case 7:
		display_seven(LCD_COL12);
     85c:	8c e0       	ldi	r24, 0x0C	; 12
     85e:	0e 94 2f 07 	call	0xe5e	; 0xe5e <display_seven>
	break;
     862:	08 95       	ret
	
	case 8:
		display_eight(LCD_COL12);
     864:	8c e0       	ldi	r24, 0x0C	; 12
     866:	0e 94 51 07 	call	0xea2	; 0xea2 <display_eight>
	break;
     86a:	08 95       	ret
	
	case 9:
		display_nine(LCD_COL12);
     86c:	8c e0       	ldi	r24, 0x0C	; 12
     86e:	0e 94 84 07 	call	0xf08	; 0xf08 <display_nine>
	break;	
     872:	08 95       	ret
	
	default:
		display_zero(LCD_COL12);
     874:	8c e0       	ldi	r24, 0x0C	; 12
     876:	0e 94 a6 07 	call	0xf4c	; 0xf4c <display_zero>
     87a:	08 95       	ret

0000087c <display_clock>:

/************************************************************************/
/* Displays the all four digits together on the LCD                              */
/************************************************************************/
void display_clock(uint8_t hour, uint8_t min)
{
     87c:	0f 93       	push	r16
     87e:	1f 93       	push	r17
     880:	cf 93       	push	r28
     882:	df 93       	push	r29
     884:	08 2f       	mov	r16, r24
     886:	16 2f       	mov	r17, r22
	
		
			
		lcd_setcursor(LCD_COL0, LCD_ROW1);			//Set the LCD cursor at desire position
     888:	61 e0       	ldi	r22, 0x01	; 1
     88a:	80 e0       	ldi	r24, 0x00	; 0
     88c:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("   ");							//Clear the chars at desire position
     890:	87 e8       	ldi	r24, 0x87	; 135
     892:	91 e0       	ldi	r25, 0x01	; 1
     894:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL0, LCD_ROW2);		
     898:	62 e0       	ldi	r22, 0x02	; 2
     89a:	80 e0       	ldi	r24, 0x00	; 0
     89c:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("   ");
     8a0:	87 e8       	ldi	r24, 0x87	; 135
     8a2:	91 e0       	ldi	r25, 0x01	; 1
     8a4:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		FirstDigit(hour/10);						//Divide the hour by 10 to subtract the first digit, e.g. 20/10 = 2
     8a8:	cd ec       	ldi	r28, 0xCD	; 205
     8aa:	0c 9f       	mul	r16, r28
     8ac:	d1 2d       	mov	r29, r1
     8ae:	11 24       	eor	r1, r1
     8b0:	d6 95       	lsr	r29
     8b2:	d6 95       	lsr	r29
     8b4:	d6 95       	lsr	r29
     8b6:	8d 2f       	mov	r24, r29
     8b8:	0e 94 94 03 	call	0x728	; 0x728 <FirstDigit>
			
		lcd_setcursor(LCD_COL3, LCD_ROW1);			
     8bc:	61 e0       	ldi	r22, 0x01	; 1
     8be:	83 e0       	ldi	r24, 0x03	; 3
     8c0:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("   ");							
     8c4:	87 e8       	ldi	r24, 0x87	; 135
     8c6:	91 e0       	ldi	r25, 0x01	; 1
     8c8:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL3, LCD_ROW2);
     8cc:	62 e0       	ldi	r22, 0x02	; 2
     8ce:	83 e0       	ldi	r24, 0x03	; 3
     8d0:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("   ");
     8d4:	87 e8       	ldi	r24, 0x87	; 135
     8d6:	91 e0       	ldi	r25, 0x01	; 1
     8d8:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		SecondDigit(hour%10);					   //Modulus the hour by 10 to subtract the second digit , e.g. 20%10 = 0 
     8dc:	dd 0f       	add	r29, r29
     8de:	8d 2f       	mov	r24, r29
     8e0:	88 0f       	add	r24, r24
     8e2:	88 0f       	add	r24, r24
     8e4:	d8 0f       	add	r29, r24
     8e6:	80 2f       	mov	r24, r16
     8e8:	8d 1b       	sub	r24, r29
     8ea:	0e 94 aa 03 	call	0x754	; 0x754 <SecondDigit>
		
		
			
		lcd_setcursor(LCD_COL8, LCD_ROW1);			//Set the LCD cursor at desire position
     8ee:	61 e0       	ldi	r22, 0x01	; 1
     8f0:	88 e0       	ldi	r24, 0x08	; 8
     8f2:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("   ");							//Clear the chars at desire position
     8f6:	87 e8       	ldi	r24, 0x87	; 135
     8f8:	91 e0       	ldi	r25, 0x01	; 1
     8fa:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL8, LCD_ROW2);
     8fe:	62 e0       	ldi	r22, 0x02	; 2
     900:	88 e0       	ldi	r24, 0x08	; 8
     902:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("   ");
     906:	87 e8       	ldi	r24, 0x87	; 135
     908:	91 e0       	ldi	r25, 0x01	; 1
     90a:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		ThirdDigit(min/10);							//Divide the hour by 10 to subtract the first digit, e.g. 20/10 = 2
     90e:	1c 9f       	mul	r17, r28
     910:	c1 2d       	mov	r28, r1
     912:	11 24       	eor	r1, r1
     914:	c6 95       	lsr	r28
     916:	c6 95       	lsr	r28
     918:	c6 95       	lsr	r28
     91a:	8c 2f       	mov	r24, r28
     91c:	0e 94 df 03 	call	0x7be	; 0x7be <ThirdDigit>
			
		lcd_setcursor(LCD_COL11, LCD_ROW1);
     920:	61 e0       	ldi	r22, 0x01	; 1
     922:	8b e0       	ldi	r24, 0x0B	; 11
     924:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("    ");
     928:	86 e8       	ldi	r24, 0x86	; 134
     92a:	91 e0       	ldi	r25, 0x01	; 1
     92c:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL11, LCD_ROW2);
     930:	62 e0       	ldi	r22, 0x02	; 2
     932:	8b e0       	ldi	r24, 0x0B	; 11
     934:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("    ");
     938:	86 e8       	ldi	r24, 0x86	; 134
     93a:	91 e0       	ldi	r25, 0x01	; 1
     93c:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		FourthDigit(min%10);						  //Modulus the hour by 10 to subtract the second digit , e.g. 20%10 = 0 
     940:	cc 0f       	add	r28, r28
     942:	8c 2f       	mov	r24, r28
     944:	88 0f       	add	r24, r24
     946:	88 0f       	add	r24, r24
     948:	c8 0f       	add	r28, r24
     94a:	81 2f       	mov	r24, r17
     94c:	8c 1b       	sub	r24, r28
     94e:	0e 94 09 04 	call	0x812	; 0x812 <FourthDigit>
			
		

}
     952:	df 91       	pop	r29
     954:	cf 91       	pop	r28
     956:	1f 91       	pop	r17
     958:	0f 91       	pop	r16
     95a:	08 95       	ret

0000095c <display_clocktemp>:

/************************************************************************/
/* Display clock and temperature at the first row in the LCD            */
/************************************************************************/
void display_clocktemp(uint8_t hour, uint8_t min, uint8_t temp)
{
     95c:	ff 92       	push	r15
     95e:	0f 93       	push	r16
     960:	1f 93       	push	r17
     962:	cf 93       	push	r28
     964:	df 93       	push	r29
     966:	f8 2e       	mov	r15, r24
     968:	06 2f       	mov	r16, r22
     96a:	14 2f       	mov	r17, r20
	
	lcd_setcursor(LCD_COL0, LCD_ROW1);											//Set the cursor at the beginning of the display
     96c:	61 e0       	ldi	r22, 0x01	; 1
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
	lcd_string("               ");												//Clear LCD
     974:	8b e7       	ldi	r24, 0x7B	; 123
     976:	91 e0       	ldi	r25, 0x01	; 1
     978:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
	lcd_generatechar(LCD_GC_CHAR1, clockchar, LCD_SET_DDADR, LCD_COL0);			//Generate the clock character
     97c:	20 e0       	ldi	r18, 0x00	; 0
     97e:	40 e8       	ldi	r20, 0x80	; 128
     980:	6a ec       	ldi	r22, 0xCA	; 202
     982:	71 e0       	ldi	r23, 0x01	; 1
     984:	81 e0       	ldi	r24, 0x01	; 1
     986:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_setcursor(LCD_COL2, LCD_ROW1);											//Set cursor at specific point
     98a:	61 e0       	ldi	r22, 0x01	; 1
     98c:	82 e0       	ldi	r24, 0x02	; 2
     98e:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
	lcd_Data(hour/10 + ASCIICHARINDEX);											//Print the hour decimal variable + ASCII index
     992:	cd ec       	ldi	r28, 0xCD	; 205
     994:	fc 9e       	mul	r15, r28
     996:	d1 2d       	mov	r29, r1
     998:	11 24       	eor	r1, r1
     99a:	d6 95       	lsr	r29
     99c:	d6 95       	lsr	r29
     99e:	d6 95       	lsr	r29
     9a0:	80 e3       	ldi	r24, 0x30	; 48
     9a2:	8d 0f       	add	r24, r29
     9a4:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
	lcd_Data(hour%10 + ASCIICHARINDEX);											//...print remainder of variable hour
     9a8:	dd 0f       	add	r29, r29
     9aa:	8d 2f       	mov	r24, r29
     9ac:	88 0f       	add	r24, r24
     9ae:	88 0f       	add	r24, r24
     9b0:	d8 0f       	add	r29, r24
     9b2:	8f 2d       	mov	r24, r15
     9b4:	8d 1b       	sub	r24, r29
     9b6:	80 5d       	subi	r24, 0xD0	; 208
     9b8:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
	
	
	
	lcd_setcursor(LCD_COL5, LCD_ROW1);											//Same as above
     9bc:	61 e0       	ldi	r22, 0x01	; 1
     9be:	85 e0       	ldi	r24, 0x05	; 5
     9c0:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
	lcd_Data(min/10 + ASCIICHARINDEX);											//...
     9c4:	0c 9f       	mul	r16, r28
     9c6:	d1 2d       	mov	r29, r1
     9c8:	11 24       	eor	r1, r1
     9ca:	d6 95       	lsr	r29
     9cc:	d6 95       	lsr	r29
     9ce:	d6 95       	lsr	r29
     9d0:	80 e3       	ldi	r24, 0x30	; 48
     9d2:	8d 0f       	add	r24, r29
     9d4:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
	lcd_Data(min%10 + ASCIICHARINDEX);											//...
     9d8:	dd 0f       	add	r29, r29
     9da:	8d 2f       	mov	r24, r29
     9dc:	88 0f       	add	r24, r24
     9de:	88 0f       	add	r24, r24
     9e0:	d8 0f       	add	r29, r24
     9e2:	80 2f       	mov	r24, r16
     9e4:	8d 1b       	sub	r24, r29
     9e6:	80 5d       	subi	r24, 0xD0	; 208
     9e8:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
	
	
	lcd_generatechar(LCD_GC_CHAR2, tempchar, LCD_SET_DDADR, LCD_COL9);			//Generate the temperature character
     9ec:	29 e0       	ldi	r18, 0x09	; 9
     9ee:	40 e8       	ldi	r20, 0x80	; 128
     9f0:	62 ec       	ldi	r22, 0xC2	; 194
     9f2:	71 e0       	ldi	r23, 0x01	; 1
     9f4:	82 e0       	ldi	r24, 0x02	; 2
     9f6:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_setcursor(LCD_COL11, LCD_ROW1);											//Same as above
     9fa:	61 e0       	ldi	r22, 0x01	; 1
     9fc:	8b e0       	ldi	r24, 0x0B	; 11
     9fe:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
	lcd_Data(temp/10 + ASCIICHARINDEX);
     a02:	1c 9f       	mul	r17, r28
     a04:	c1 2d       	mov	r28, r1
     a06:	11 24       	eor	r1, r1
     a08:	c6 95       	lsr	r28
     a0a:	c6 95       	lsr	r28
     a0c:	c6 95       	lsr	r28
     a0e:	80 e3       	ldi	r24, 0x30	; 48
     a10:	8c 0f       	add	r24, r28
     a12:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
	lcd_Data(temp%10 + ASCIICHARINDEX);
     a16:	cc 0f       	add	r28, r28
     a18:	8c 2f       	mov	r24, r28
     a1a:	88 0f       	add	r24, r24
     a1c:	88 0f       	add	r24, r24
     a1e:	c8 0f       	add	r28, r24
     a20:	81 2f       	mov	r24, r17
     a22:	8c 1b       	sub	r24, r28
     a24:	80 5d       	subi	r24, 0xD0	; 208
     a26:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>

	
	lcd_generatechar(LCD_GC_CHAR3, celsiuschar, LCD_SET_DDADR, LCD_COL13);		//Genereate the celsius character
     a2a:	2d e0       	ldi	r18, 0x0D	; 13
     a2c:	40 e8       	ldi	r20, 0x80	; 128
     a2e:	6a eb       	ldi	r22, 0xBA	; 186
     a30:	71 e0       	ldi	r23, 0x01	; 1
     a32:	83 e0       	ldi	r24, 0x03	; 3
     a34:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_setcursor(LCD_COL14, LCD_ROW1);
     a38:	61 e0       	ldi	r22, 0x01	; 1
     a3a:	8e e0       	ldi	r24, 0x0E	; 14
     a3c:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
	lcd_string("C");
     a40:	87 e7       	ldi	r24, 0x77	; 119
     a42:	91 e0       	ldi	r25, 0x01	; 1
     a44:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
	
	
	
	
     a48:	df 91       	pop	r29
     a4a:	cf 91       	pop	r28
     a4c:	1f 91       	pop	r17
     a4e:	0f 91       	pop	r16
     a50:	ff 90       	pop	r15
     a52:	08 95       	ret

00000a54 <lcd_Enable>:
//Description: Sends an enable pulse to the LCD
//================================================
 void lcd_Enable(void)
{
	
	PORTB |=  (1 << LCD_EN);					//High pulse state
     a54:	28 9a       	sbi	0x05, 0	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     a56:	8a e6       	ldi	r24, 0x6A	; 106
     a58:	8a 95       	dec	r24
     a5a:	f1 f7       	brne	.-4      	; 0xa58 <lcd_Enable+0x4>
     a5c:	00 c0       	rjmp	.+0      	; 0xa5e <lcd_Enable+0xa>
	_delay_us(LCD_ENABLE_US);					//wait
	PORTB &= ~(1 << LCD_EN);					//Low pulse state
     a5e:	28 98       	cbi	0x05, 0	; 5
     a60:	08 95       	ret

00000a62 <lcd_Out>:
//================================================
void lcd_Out(uint8_t data)
{
	data &= 0xF0;								// Mask upper 4-Bit in data
	
	LCD_PORTD &= ~(0xF0 >> (4 - LCD_D4));		// Delete upper mask in LCD PORT
     a62:	9b b1       	in	r25, 0x0b	; 11
     a64:	9f 70       	andi	r25, 0x0F	; 15
     a66:	9b b9       	out	0x0b, r25	; 11
	LCD_PORTD |= (data >> (4 - LCD_D4));		// Send the 4-bit data
     a68:	9b b1       	in	r25, 0x0b	; 11
     a6a:	80 7f       	andi	r24, 0xF0	; 240
     a6c:	98 2b       	or	r25, r24
     a6e:	9b b9       	out	0x0b, r25	; 11
	lcd_Enable();								// Enable LCD latch
     a70:	0e 94 2a 05 	call	0xa54	; 0xa54 <lcd_Enable>
     a74:	08 95       	ret

00000a76 <lcd_Cmd>:

//================================================
//Description: Sends LCD-commands to the LCD
//================================================
void lcd_Cmd(uint8_t data)
{
     a76:	cf 93       	push	r28
     a78:	c8 2f       	mov	r28, r24
	PORTB &= ~(1<<LCD_RS);						// Send data command, RS=0
     a7a:	29 98       	cbi	0x05, 1	; 5
	
	lcd_Out(data);								// Send upper 4 bits to PORT D
     a7c:	0e 94 31 05 	call	0xa62	; 0xa62 <lcd_Out>
	lcd_Out(data << 4 );						// Then lower 4 bits to PORT D
     a80:	8c 2f       	mov	r24, r28
     a82:	82 95       	swap	r24
     a84:	80 7f       	andi	r24, 0xF0	; 240
     a86:	0e 94 31 05 	call	0xa62	; 0xa62 <lcd_Out>
     a8a:	80 ee       	ldi	r24, 0xE0	; 224
     a8c:	8a 95       	dec	r24
     a8e:	f1 f7       	brne	.-4      	; 0xa8c <lcd_Cmd+0x16>
	_delay_us(LCD_COMMAND_US);
}
     a90:	cf 91       	pop	r28
     a92:	08 95       	ret

00000a94 <lcd_Data>:

//================================================
//Description: Sends 8-bit data to print on the LCD
//================================================
void lcd_Data( uint8_t data )
{
     a94:	cf 93       	push	r28
     a96:	c8 2f       	mov	r28, r24
	PORTB |= (1 << LCD_RS);						// Send print data to LCD, RS=1
     a98:	29 9a       	sbi	0x05, 1	; 5
	
	lcd_Out(data);								// Send upper data nibble
     a9a:	0e 94 31 05 	call	0xa62	; 0xa62 <lcd_Out>
	lcd_Out(data << 4);						// Send lower data nibble
     a9e:	8c 2f       	mov	r24, r28
     aa0:	82 95       	swap	r24
     aa2:	80 7f       	andi	r24, 0xF0	; 240
     aa4:	0e 94 31 05 	call	0xa62	; 0xa62 <lcd_Out>
     aa8:	85 ef       	ldi	r24, 0xF5	; 245
     aaa:	8a 95       	dec	r24
     aac:	f1 f7       	brne	.-4      	; 0xaaa <lcd_Data+0x16>
     aae:	00 00       	nop
	_delay_us(LCD_WRITEDATA_US);							
}
     ab0:	cf 91       	pop	r28
     ab2:	08 95       	ret

00000ab4 <lcd_clear>:
//================================================
//Description: Clear LCD function
//================================================
void lcd_clear( void )
{
	lcd_Cmd(0x01);
     ab4:	81 e0       	ldi	r24, 0x01	; 1
     ab6:	0e 94 3b 05 	call	0xa76	; 0xa76 <lcd_Cmd>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     aba:	8f e3       	ldi	r24, 0x3F	; 63
     abc:	9f e1       	ldi	r25, 0x1F	; 31
     abe:	01 97       	sbiw	r24, 0x01	; 1
     ac0:	f1 f7       	brne	.-4      	; 0xabe <lcd_clear+0xa>
     ac2:	00 c0       	rjmp	.+0      	; 0xac4 <lcd_clear+0x10>
     ac4:	00 00       	nop
     ac6:	08 95       	ret

00000ac8 <lcd_string>:

//================================================
//Description: Write a string to the LCD
//================================================
void lcd_string( const char *data )
{
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	ec 01       	movw	r28, r24
	while( *data != '\0' )
     ace:	88 81       	ld	r24, Y
     ad0:	88 23       	and	r24, r24
     ad2:	31 f0       	breq	.+12     	; 0xae0 <lcd_string+0x18>
     ad4:	21 96       	adiw	r28, 0x01	; 1
	lcd_Data( *data++ );
     ad6:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
//================================================
//Description: Write a string to the LCD
//================================================
void lcd_string( const char *data )
{
	while( *data != '\0' )
     ada:	89 91       	ld	r24, Y+
     adc:	81 11       	cpse	r24, r1
     ade:	fb cf       	rjmp	.-10     	; 0xad6 <lcd_string+0xe>
	lcd_Data( *data++ );
}
     ae0:	df 91       	pop	r29
     ae2:	cf 91       	pop	r28
     ae4:	08 95       	ret

00000ae6 <lcd_home>:
//==================================================
//Description: Send the cursor home command
//==================================================
void lcd_home( void )
{
	lcd_Cmd( LCD_CURSOR_HOME );
     ae6:	82 e0       	ldi	r24, 0x02	; 2
     ae8:	0e 94 3b 05 	call	0xa76	; 0xa76 <lcd_Cmd>
     aec:	8f e3       	ldi	r24, 0x3F	; 63
     aee:	9f e1       	ldi	r25, 0x1F	; 31
     af0:	01 97       	sbiw	r24, 0x01	; 1
     af2:	f1 f7       	brne	.-4      	; 0xaf0 <lcd_home+0xa>
     af4:	00 c0       	rjmp	.+0      	; 0xaf6 <lcd_home+0x10>
     af6:	00 00       	nop
     af8:	08 95       	ret

00000afa <lcd_setcursor>:
 
void lcd_setcursor(uint8_t x, uint8_t y)
{
    uint8_t data;
 
    switch (y)
     afa:	61 30       	cpi	r22, 0x01	; 1
     afc:	19 f0       	breq	.+6      	; 0xb04 <lcd_setcursor+0xa>
     afe:	62 30       	cpi	r22, 0x02	; 2
     b00:	19 f0       	breq	.+6      	; 0xb08 <lcd_setcursor+0xe>
     b02:	08 95       	ret
    {
        case 1:    // 1. Row		Line 1
            data = LCD_SET_DDADR + LCD_DDADR_LINE1 + x;
     b04:	80 58       	subi	r24, 0x80	; 128
            break;
     b06:	01 c0       	rjmp	.+2      	; 0xb0a <lcd_setcursor+0x10>
 
        case 2:    // 2. Row		Line 2
            data = LCD_SET_DDADR + LCD_DDADR_LINE2 + x;
     b08:	80 54       	subi	r24, 0x40	; 64
 
        default:
            return;                                   // default case
    }
 
    lcd_Cmd(data);
     b0a:	0e 94 3b 05 	call	0xa76	; 0xa76 <lcd_Cmd>
     b0e:	08 95       	ret

00000b10 <lcd_string_clear>:
//================================================
//Description: Clears the LCD (faster mode)
//================================================
void lcd_string_clear(void)
{
	lcd_setcursor(LCD_COL0, LCD_ROW1);
     b10:	61 e0       	ldi	r22, 0x01	; 1
     b12:	80 e0       	ldi	r24, 0x00	; 0
     b14:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
	lcd_string("                 ");
     b18:	89 e7       	ldi	r24, 0x79	; 121
     b1a:	91 e0       	ldi	r25, 0x01	; 1
     b1c:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
	lcd_setcursor(LCD_COL0, LCD_ROW2);
     b20:	62 e0       	ldi	r22, 0x02	; 2
     b22:	80 e0       	ldi	r24, 0x00	; 0
     b24:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
	lcd_string("                 ");
     b28:	89 e7       	ldi	r24, 0x79	; 121
     b2a:	91 e0       	ldi	r25, 0x01	; 1
     b2c:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
     b30:	08 95       	ret

00000b32 <lcd_generatechar>:

/************************************************************************
Description: Write a character into the character generator RAM                                              
************************************************************************/

void lcd_generatechar( uint8_t startaddress, const uint8_t *data, uint8_t line, uint8_t column){
     b32:	df 92       	push	r13
     b34:	ef 92       	push	r14
     b36:	ff 92       	push	r15
     b38:	0f 93       	push	r16
     b3a:	1f 93       	push	r17
     b3c:	cf 93       	push	r28
     b3e:	df 93       	push	r29
     b40:	f8 2e       	mov	r15, r24
     b42:	8b 01       	movw	r16, r22
     b44:	d4 2e       	mov	r13, r20
     b46:	e2 2e       	mov	r14, r18
	

    // Set the start position of the character 0,1,2,3,4,5,6,7
    lcd_Cmd( LCD_SET_CGADR | (startaddress << 3) ); 
     b48:	88 0f       	add	r24, r24
     b4a:	88 0f       	add	r24, r24
     b4c:	88 0f       	add	r24, r24
     b4e:	80 64       	ori	r24, 0x40	; 64
     b50:	0e 94 3b 05 	call	0xa76	; 0xa76 <lcd_Cmd>
     b54:	e8 01       	movw	r28, r16
     b56:	08 5f       	subi	r16, 0xF8	; 248
     b58:	1f 4f       	sbci	r17, 0xFF	; 255
    
    //Bit patterns
    for ( uint8_t i=0; i<8; i++ )
    {
	    lcd_Data( data[i] );
     b5a:	89 91       	ld	r24, Y+
     b5c:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>

    // Set the start position of the character 0,1,2,3,4,5,6,7
    lcd_Cmd( LCD_SET_CGADR | (startaddress << 3) ); 
    
    //Bit patterns
    for ( uint8_t i=0; i<8; i++ )
     b60:	c0 17       	cp	r28, r16
     b62:	d1 07       	cpc	r29, r17
     b64:	d1 f7       	brne	.-12     	; 0xb5a <lcd_generatechar+0x28>
    {
	    lcd_Data( data[i] );
    }
	
	lcd_Cmd(line + column); // Set DRAM (Line1), address on the LCD where the bit patterns are displayed
     b66:	8d 2d       	mov	r24, r13
     b68:	8e 0d       	add	r24, r14
     b6a:	0e 94 3b 05 	call	0xa76	; 0xa76 <lcd_Cmd>
	lcd_Data(startaddress);	// Display the bit pattern on the stored address
     b6e:	8f 2d       	mov	r24, r15
     b70:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_Data>
	
  
    
}
     b74:	df 91       	pop	r29
     b76:	cf 91       	pop	r28
     b78:	1f 91       	pop	r17
     b7a:	0f 91       	pop	r16
     b7c:	ff 90       	pop	r15
     b7e:	ef 90       	pop	r14
     b80:	df 90       	pop	r13
     b82:	08 95       	ret

00000b84 <lcd_setcurstring>:
/************************************************************************/
/* Set the cursor to a certain position and prints a string				*/
/************************************************************************/
void lcd_setcurstring(uint8_t x, uint8_t y, const char *data)
{
     b84:	cf 93       	push	r28
     b86:	df 93       	push	r29
     b88:	ea 01       	movw	r28, r20
	lcd_setcursor(x, y);
     b8a:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
	lcd_string(data);
     b8e:	ce 01       	movw	r24, r28
     b90:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
}
     b94:	df 91       	pop	r29
     b96:	cf 91       	pop	r28
     b98:	08 95       	ret

00000b9a <lcd_Init>:

void lcd_Init(void)
{
	
	//Pins in PORT D and PORT B as outputs
	DDRD |=  (0X0F << LCD_D4);
     b9a:	8a b1       	in	r24, 0x0a	; 10
     b9c:	80 6f       	ori	r24, 0xF0	; 240
     b9e:	8a b9       	out	0x0a, r24	; 10
	DDRB |= (1 << LCD_RS) | (1 << LCD_EN);
     ba0:	84 b1       	in	r24, 0x04	; 4
     ba2:	83 60       	ori	r24, 0x03	; 3
     ba4:	84 b9       	out	0x04, r24	; 4
	
	//Initialize pins in PORT D and PORT B as Zero
	PORTB &= ~(1 << LCD_EN);
     ba6:	28 98       	cbi	0x05, 0	; 5
	PORTB &= ~(1 << LCD_RS);  
     ba8:	29 98       	cbi	0x05, 1	; 5
	LCD_PORTD &= ~(0x0F << LCD_D4);  
     baa:	8b b1       	in	r24, 0x0b	; 11
     bac:	8f 70       	andi	r24, 0x0F	; 15
     bae:	8b b9       	out	0x0b, r24	; 11
     bb0:	8f e5       	ldi	r24, 0x5F	; 95
     bb2:	9a ee       	ldi	r25, 0xEA	; 234
     bb4:	01 97       	sbiw	r24, 0x01	; 1
     bb6:	f1 f7       	brne	.-4      	; 0xbb4 <lcd_Init+0x1a>
     bb8:	00 c0       	rjmp	.+0      	; 0xbba <lcd_Init+0x20>
     bba:	00 00       	nop
	
	
	//===============Start up sequence==========================	
	 _delay_ms(LCD_BOOTUP_MS);								//Power on delay
	 
	 lcd_Out(LCD_SOFT_RESET);								//Send first start up
     bbc:	80 e3       	ldi	r24, 0x30	; 48
     bbe:	0e 94 31 05 	call	0xa62	; 0xa62 <lcd_Out>
     bc2:	8f e1       	ldi	r24, 0x1F	; 31
     bc4:	9e e4       	ldi	r25, 0x4E	; 78
     bc6:	01 97       	sbiw	r24, 0x01	; 1
     bc8:	f1 f7       	brne	.-4      	; 0xbc6 <lcd_Init+0x2c>
     bca:	00 c0       	rjmp	.+0      	; 0xbcc <lcd_Init+0x32>
     bcc:	00 00       	nop
	 _delay_ms(LCD_SOFT_RESET_MS1);			
	 
	 lcd_Enable();											//Send second start up					
     bce:	0e 94 2a 05 	call	0xa54	; 0xa54 <lcd_Enable>
     bd2:	8f e9       	ldi	r24, 0x9F	; 159
     bd4:	9f e0       	ldi	r25, 0x0F	; 15
     bd6:	01 97       	sbiw	r24, 0x01	; 1
     bd8:	f1 f7       	brne	.-4      	; 0xbd6 <lcd_Init+0x3c>
     bda:	00 c0       	rjmp	.+0      	; 0xbdc <lcd_Init+0x42>
     bdc:	00 00       	nop
	 _delay_ms(LCD_SOFT_RESET_MS2);
	 
	 lcd_Enable();											//Send third start up
     bde:	0e 94 2a 05 	call	0xa54	; 0xa54 <lcd_Enable>
     be2:	8f e9       	ldi	r24, 0x9F	; 159
     be4:	9f e0       	ldi	r25, 0x0F	; 15
     be6:	01 97       	sbiw	r24, 0x01	; 1
     be8:	f1 f7       	brne	.-4      	; 0xbe6 <lcd_Init+0x4c>
     bea:	00 c0       	rjmp	.+0      	; 0xbec <lcd_Init+0x52>
     bec:	00 00       	nop
	 _delay_ms(LCD_SOFT_RESET_MS3);
	
	 lcd_Out(LCD_SET_FUNCTION | LCD_FUNCTION_4BIT);			// 4-bit mode on
     bee:	80 e2       	ldi	r24, 0x20	; 32
     bf0:	0e 94 31 05 	call	0xa62	; 0xa62 <lcd_Out>
     bf4:	8f e1       	ldi	r24, 0x1F	; 31
     bf6:	9e e4       	ldi	r25, 0x4E	; 78
     bf8:	01 97       	sbiw	r24, 0x01	; 1
     bfa:	f1 f7       	brne	.-4      	; 0xbf8 <lcd_Init+0x5e>
     bfc:	00 c0       	rjmp	.+0      	; 0xbfe <lcd_Init+0x64>
     bfe:	00 00       	nop
	 _delay_ms(LCD_SET_4BITMODE_MS);
	
	 lcd_Cmd(LCD_SET_FUNCTION | LCD_FUNCTION_4BIT | LCD_FUNCTION_2LINE | LCD_FUNCTION_5X7);					// 4-bit mode / 2 lines / 5x7 font size
     c00:	88 e2       	ldi	r24, 0x28	; 40
     c02:	0e 94 3b 05 	call	0xa76	; 0xa76 <lcd_Cmd>
	
	 
	 lcd_Cmd(LCD_SET_DISPLAY | LCD_DISPLAY_ON | LCD_CURSOR_OFF | LCD_BLINKING_OFF);					// Display on / Cursor on / Blinking on
     c06:	8c e0       	ldi	r24, 0x0C	; 12
     c08:	0e 94 3b 05 	call	0xa76	; 0xa76 <lcd_Cmd>
	 
	  
	 lcd_Cmd(LCD_SET_ENTRY | LCD_ENTRY_INCREASE | LCD_ENTRY_NOSHIFT );						// Cursor increment and no scrolling of the LCD
     c0c:	86 e0       	ldi	r24, 0x06	; 6
     c0e:	0e 94 3b 05 	call	0xa76	; 0xa76 <lcd_Cmd>
	
	 lcd_clear();
     c12:	0e 94 5a 05 	call	0xab4	; 0xab4 <lcd_clear>
     c16:	08 95       	ret

00000c18 <display_one>:

return: -
***************************************************************************************************/

void display_one(uint8_t col)
{
     c18:	cf 93       	push	r28
     c1a:	df 93       	push	r29
     c1c:	c8 2f       	mov	r28, r24
	
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col+1);
     c1e:	d1 e0       	ldi	r29, 0x01	; 1
     c20:	d8 0f       	add	r29, r24
     c22:	2d 2f       	mov	r18, r29
     c24:	40 e8       	ldi	r20, 0x80	; 128
     c26:	6a ef       	ldi	r22, 0xFA	; 250
     c28:	71 e0       	ldi	r23, 0x01	; 1
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR3, customChar3, LCD_SET_DDADR, col);
     c30:	2c 2f       	mov	r18, r28
     c32:	40 e8       	ldi	r20, 0x80	; 128
     c34:	62 ee       	ldi	r22, 0xE2	; 226
     c36:	71 e0       	ldi	r23, 0x01	; 1
     c38:	83 e0       	ldi	r24, 0x03	; 3
     c3a:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col+1);
     c3e:	2d 2f       	mov	r18, r29
     c40:	40 ec       	ldi	r20, 0xC0	; 192
     c42:	6a ef       	ldi	r22, 0xFA	; 250
     c44:	71 e0       	ldi	r23, 0x01	; 1
     c46:	80 e0       	ldi	r24, 0x00	; 0
     c48:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR2, col+2);
     c4c:	22 e0       	ldi	r18, 0x02	; 2
     c4e:	2c 0f       	add	r18, r28
     c50:	40 ec       	ldi	r20, 0xC0	; 192
     c52:	6a ee       	ldi	r22, 0xEA	; 234
     c54:	71 e0       	ldi	r23, 0x01	; 1
     c56:	82 e0       	ldi	r24, 0x02	; 2
     c58:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR2, col);
     c5c:	2c 2f       	mov	r18, r28
     c5e:	40 ec       	ldi	r20, 0xC0	; 192
     c60:	6a ee       	ldi	r22, 0xEA	; 234
     c62:	71 e0       	ldi	r23, 0x01	; 1
     c64:	82 e0       	ldi	r24, 0x02	; 2
     c66:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	
}
     c6a:	df 91       	pop	r29
     c6c:	cf 91       	pop	r28
     c6e:	08 95       	ret

00000c70 <display_two>:
			 row position (LCD_SET_DDADR,LCD_SET_DDADR2), column position (LCD_COL0..LCD_COL16)

return: -
***************************************************************************************************/
void display_two(uint8_t col)
{
     c70:	1f 93       	push	r17
     c72:	cf 93       	push	r28
     c74:	df 93       	push	r29
     c76:	c8 2f       	mov	r28, r24
	
	
	lcd_generatechar(LCD_GC_CHAR1, customChar1, LCD_SET_DDADR, col);
     c78:	28 2f       	mov	r18, r24
     c7a:	40 e8       	ldi	r20, 0x80	; 128
     c7c:	62 ef       	ldi	r22, 0xF2	; 242
     c7e:	71 e0       	ldi	r23, 0x01	; 1
     c80:	81 e0       	ldi	r24, 0x01	; 1
     c82:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR1, customChar1, LCD_SET_DDADR, col+1);
     c86:	11 e0       	ldi	r17, 0x01	; 1
     c88:	1c 0f       	add	r17, r28
     c8a:	21 2f       	mov	r18, r17
     c8c:	40 e8       	ldi	r20, 0x80	; 128
     c8e:	62 ef       	ldi	r22, 0xF2	; 242
     c90:	71 e0       	ldi	r23, 0x01	; 1
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col+2);
     c98:	d2 e0       	ldi	r29, 0x02	; 2
     c9a:	dc 0f       	add	r29, r28
     c9c:	2d 2f       	mov	r18, r29
     c9e:	40 e8       	ldi	r20, 0x80	; 128
     ca0:	6a ef       	ldi	r22, 0xFA	; 250
     ca2:	71 e0       	ldi	r23, 0x01	; 1
     ca4:	80 e0       	ldi	r24, 0x00	; 0
     ca6:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col);
     caa:	2c 2f       	mov	r18, r28
     cac:	40 ec       	ldi	r20, 0xC0	; 192
     cae:	6a ef       	ldi	r22, 0xFA	; 250
     cb0:	71 e0       	ldi	r23, 0x01	; 1
     cb2:	80 e0       	ldi	r24, 0x00	; 0
     cb4:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR2, col+1);
     cb8:	21 2f       	mov	r18, r17
     cba:	40 ec       	ldi	r20, 0xC0	; 192
     cbc:	6a ee       	ldi	r22, 0xEA	; 234
     cbe:	71 e0       	ldi	r23, 0x01	; 1
     cc0:	82 e0       	ldi	r24, 0x02	; 2
     cc2:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR2, col+2);
     cc6:	2d 2f       	mov	r18, r29
     cc8:	40 ec       	ldi	r20, 0xC0	; 192
     cca:	6a ee       	ldi	r22, 0xEA	; 234
     ccc:	71 e0       	ldi	r23, 0x01	; 1
     cce:	82 e0       	ldi	r24, 0x02	; 2
     cd0:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>

	
}
     cd4:	df 91       	pop	r29
     cd6:	cf 91       	pop	r28
     cd8:	1f 91       	pop	r17
     cda:	08 95       	ret

00000cdc <display_three>:
			 row position (LCD_SET_DDADR,LCD_SET_DDADR2), column position (LCD_COL0..LCD_COL16)

return: -
***************************************************************************************************/
void display_three(uint8_t col)
{
     cdc:	1f 93       	push	r17
     cde:	cf 93       	push	r28
     ce0:	df 93       	push	r29
     ce2:	c8 2f       	mov	r28, r24
	
	//======================Number three==================================================
	
	lcd_generatechar(LCD_GC_CHAR3, customChar3, LCD_SET_DDADR, col);
     ce4:	28 2f       	mov	r18, r24
     ce6:	40 e8       	ldi	r20, 0x80	; 128
     ce8:	62 ee       	ldi	r22, 0xE2	; 226
     cea:	71 e0       	ldi	r23, 0x01	; 1
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR1, customChar1, LCD_SET_DDADR, col+1);
     cf2:	d1 e0       	ldi	r29, 0x01	; 1
     cf4:	dc 0f       	add	r29, r28
     cf6:	2d 2f       	mov	r18, r29
     cf8:	40 e8       	ldi	r20, 0x80	; 128
     cfa:	62 ef       	ldi	r22, 0xF2	; 242
     cfc:	71 e0       	ldi	r23, 0x01	; 1
     cfe:	81 e0       	ldi	r24, 0x01	; 1
     d00:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col+2);
     d04:	12 e0       	ldi	r17, 0x02	; 2
     d06:	1c 0f       	add	r17, r28
     d08:	21 2f       	mov	r18, r17
     d0a:	40 ec       	ldi	r20, 0xC0	; 192
     d0c:	6a ef       	ldi	r22, 0xFA	; 250
     d0e:	71 e0       	ldi	r23, 0x01	; 1
     d10:	80 e0       	ldi	r24, 0x00	; 0
     d12:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col+2);
     d16:	21 2f       	mov	r18, r17
     d18:	40 e8       	ldi	r20, 0x80	; 128
     d1a:	6a ef       	ldi	r22, 0xFA	; 250
     d1c:	71 e0       	ldi	r23, 0x01	; 1
     d1e:	80 e0       	ldi	r24, 0x00	; 0
     d20:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR2, col+1);
     d24:	2d 2f       	mov	r18, r29
     d26:	40 ec       	ldi	r20, 0xC0	; 192
     d28:	6a ee       	ldi	r22, 0xEA	; 234
     d2a:	71 e0       	ldi	r23, 0x01	; 1
     d2c:	82 e0       	ldi	r24, 0x02	; 2
     d2e:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR2, col);
     d32:	2c 2f       	mov	r18, r28
     d34:	40 ec       	ldi	r20, 0xC0	; 192
     d36:	6a ee       	ldi	r22, 0xEA	; 234
     d38:	71 e0       	ldi	r23, 0x01	; 1
     d3a:	82 e0       	ldi	r24, 0x02	; 2
     d3c:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	//==================================================================================

	
}
     d40:	df 91       	pop	r29
     d42:	cf 91       	pop	r28
     d44:	1f 91       	pop	r17
     d46:	08 95       	ret

00000d48 <display_four>:
			 row position (LCD_SET_DDADR,LCD_SET_DDADR2), column position (LCD_COL0..LCD_COL16)

return: -
***************************************************************************************************/
void display_four(uint8_t col)
{
     d48:	cf 93       	push	r28
     d4a:	c8 2f       	mov	r28, r24
	
		//======================Number four==================================================
	
		
		lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col);
     d4c:	28 2f       	mov	r18, r24
     d4e:	40 e8       	ldi	r20, 0x80	; 128
     d50:	6a ef       	ldi	r22, 0xFA	; 250
     d52:	71 e0       	ldi	r23, 0x01	; 1
     d54:	80 e0       	ldi	r24, 0x00	; 0
     d56:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
		lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR, col+1);
     d5a:	21 e0       	ldi	r18, 0x01	; 1
     d5c:	2c 0f       	add	r18, r28
     d5e:	40 e8       	ldi	r20, 0x80	; 128
     d60:	6a ee       	ldi	r22, 0xEA	; 234
     d62:	71 e0       	ldi	r23, 0x01	; 1
     d64:	82 e0       	ldi	r24, 0x02	; 2
     d66:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
		lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col+2);
     d6a:	ce 5f       	subi	r28, 0xFE	; 254
     d6c:	2c 2f       	mov	r18, r28
     d6e:	40 e8       	ldi	r20, 0x80	; 128
     d70:	6a ef       	ldi	r22, 0xFA	; 250
     d72:	71 e0       	ldi	r23, 0x01	; 1
     d74:	80 e0       	ldi	r24, 0x00	; 0
     d76:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
		lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col+2);
     d7a:	2c 2f       	mov	r18, r28
     d7c:	40 ec       	ldi	r20, 0xC0	; 192
     d7e:	6a ef       	ldi	r22, 0xFA	; 250
     d80:	71 e0       	ldi	r23, 0x01	; 1
     d82:	80 e0       	ldi	r24, 0x00	; 0
     d84:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
		
		//==================================================================================

	
}
     d88:	cf 91       	pop	r28
     d8a:	08 95       	ret

00000d8c <display_five>:
			 row position (LCD_SET_DDADR,LCD_SET_DDADR2), column position (LCD_COL0..LCD_COL16)

return: -
***************************************************************************************************/
void display_five(uint8_t col)
{
     d8c:	1f 93       	push	r17
     d8e:	cf 93       	push	r28
     d90:	df 93       	push	r29
     d92:	c8 2f       	mov	r28, r24
	
	//======================Number five==================================================
	
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col);
     d94:	28 2f       	mov	r18, r24
     d96:	40 e8       	ldi	r20, 0x80	; 128
     d98:	6a ef       	ldi	r22, 0xFA	; 250
     d9a:	71 e0       	ldi	r23, 0x01	; 1
     d9c:	80 e0       	ldi	r24, 0x00	; 0
     d9e:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR1, customChar1, LCD_SET_DDADR, col+1);
     da2:	d1 e0       	ldi	r29, 0x01	; 1
     da4:	dc 0f       	add	r29, r28
     da6:	2d 2f       	mov	r18, r29
     da8:	40 e8       	ldi	r20, 0x80	; 128
     daa:	62 ef       	ldi	r22, 0xF2	; 242
     dac:	71 e0       	ldi	r23, 0x01	; 1
     dae:	81 e0       	ldi	r24, 0x01	; 1
     db0:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR1, customChar1, LCD_SET_DDADR, col+2);
     db4:	12 e0       	ldi	r17, 0x02	; 2
     db6:	1c 0f       	add	r17, r28
     db8:	21 2f       	mov	r18, r17
     dba:	40 e8       	ldi	r20, 0x80	; 128
     dbc:	62 ef       	ldi	r22, 0xF2	; 242
     dbe:	71 e0       	ldi	r23, 0x01	; 1
     dc0:	81 e0       	ldi	r24, 0x01	; 1
     dc2:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col+2);
     dc6:	21 2f       	mov	r18, r17
     dc8:	40 ec       	ldi	r20, 0xC0	; 192
     dca:	6a ef       	ldi	r22, 0xFA	; 250
     dcc:	71 e0       	ldi	r23, 0x01	; 1
     dce:	80 e0       	ldi	r24, 0x00	; 0
     dd0:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR2, col+1);
     dd4:	2d 2f       	mov	r18, r29
     dd6:	40 ec       	ldi	r20, 0xC0	; 192
     dd8:	6a ee       	ldi	r22, 0xEA	; 234
     dda:	71 e0       	ldi	r23, 0x01	; 1
     ddc:	82 e0       	ldi	r24, 0x02	; 2
     dde:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR2, col);
     de2:	2c 2f       	mov	r18, r28
     de4:	40 ec       	ldi	r20, 0xC0	; 192
     de6:	6a ee       	ldi	r22, 0xEA	; 234
     de8:	71 e0       	ldi	r23, 0x01	; 1
     dea:	82 e0       	ldi	r24, 0x02	; 2
     dec:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	
	//==================================================================================

	
}
     df0:	df 91       	pop	r29
     df2:	cf 91       	pop	r28
     df4:	1f 91       	pop	r17
     df6:	08 95       	ret

00000df8 <display_six>:
			 row position (LCD_SET_DDADR,LCD_SET_DDADR2), column position (LCD_COL0..LCD_COL16)

return: -
***************************************************************************************************/
void display_six(uint8_t col)
{
     df8:	cf 93       	push	r28
     dfa:	df 93       	push	r29
     dfc:	c8 2f       	mov	r28, r24
	
	
//======================Number six==================================================
	
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col);
     dfe:	28 2f       	mov	r18, r24
     e00:	40 e8       	ldi	r20, 0x80	; 128
     e02:	6a ef       	ldi	r22, 0xFA	; 250
     e04:	71 e0       	ldi	r23, 0x01	; 1
     e06:	80 e0       	ldi	r24, 0x00	; 0
     e08:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col);
     e0c:	2c 2f       	mov	r18, r28
     e0e:	40 ec       	ldi	r20, 0xC0	; 192
     e10:	6a ef       	ldi	r22, 0xFA	; 250
     e12:	71 e0       	ldi	r23, 0x01	; 1
     e14:	80 e0       	ldi	r24, 0x00	; 0
     e16:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR1, customChar1, LCD_SET_DDADR, col+1);
     e1a:	d1 e0       	ldi	r29, 0x01	; 1
     e1c:	dc 0f       	add	r29, r28
     e1e:	2d 2f       	mov	r18, r29
     e20:	40 e8       	ldi	r20, 0x80	; 128
     e22:	62 ef       	ldi	r22, 0xF2	; 242
     e24:	71 e0       	ldi	r23, 0x01	; 1
     e26:	81 e0       	ldi	r24, 0x01	; 1
     e28:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR1, customChar1, LCD_SET_DDADR, col+2);
     e2c:	ce 5f       	subi	r28, 0xFE	; 254
     e2e:	2c 2f       	mov	r18, r28
     e30:	40 e8       	ldi	r20, 0x80	; 128
     e32:	62 ef       	ldi	r22, 0xF2	; 242
     e34:	71 e0       	ldi	r23, 0x01	; 1
     e36:	81 e0       	ldi	r24, 0x01	; 1
     e38:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col+2);
     e3c:	2c 2f       	mov	r18, r28
     e3e:	40 ec       	ldi	r20, 0xC0	; 192
     e40:	6a ef       	ldi	r22, 0xFA	; 250
     e42:	71 e0       	ldi	r23, 0x01	; 1
     e44:	80 e0       	ldi	r24, 0x00	; 0
     e46:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR2, col+1);
     e4a:	2d 2f       	mov	r18, r29
     e4c:	40 ec       	ldi	r20, 0xC0	; 192
     e4e:	6a ee       	ldi	r22, 0xEA	; 234
     e50:	71 e0       	ldi	r23, 0x01	; 1
     e52:	82 e0       	ldi	r24, 0x02	; 2
     e54:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
//==================================================================================
	
}
     e58:	df 91       	pop	r29
     e5a:	cf 91       	pop	r28
     e5c:	08 95       	ret

00000e5e <display_seven>:
			 row position (LCD_SET_DDADR,LCD_SET_DDADR2), column position (LCD_COL0..LCD_COL16)

return: -
***************************************************************************************************/
void display_seven(uint8_t col)
{
     e5e:	cf 93       	push	r28
     e60:	c8 2f       	mov	r28, r24
	
	//======================Number seven==================================================
	
	lcd_generatechar(LCD_GC_CHAR3, customChar3, LCD_SET_DDADR, col);
     e62:	28 2f       	mov	r18, r24
     e64:	40 e8       	ldi	r20, 0x80	; 128
     e66:	62 ee       	ldi	r22, 0xE2	; 226
     e68:	71 e0       	ldi	r23, 0x01	; 1
     e6a:	83 e0       	ldi	r24, 0x03	; 3
     e6c:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR3, customChar3, LCD_SET_DDADR, col+1);
     e70:	21 e0       	ldi	r18, 0x01	; 1
     e72:	2c 0f       	add	r18, r28
     e74:	40 e8       	ldi	r20, 0x80	; 128
     e76:	62 ee       	ldi	r22, 0xE2	; 226
     e78:	71 e0       	ldi	r23, 0x01	; 1
     e7a:	83 e0       	ldi	r24, 0x03	; 3
     e7c:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col+2);
     e80:	ce 5f       	subi	r28, 0xFE	; 254
     e82:	2c 2f       	mov	r18, r28
     e84:	40 e8       	ldi	r20, 0x80	; 128
     e86:	6a ef       	ldi	r22, 0xFA	; 250
     e88:	71 e0       	ldi	r23, 0x01	; 1
     e8a:	80 e0       	ldi	r24, 0x00	; 0
     e8c:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col+2);
     e90:	2c 2f       	mov	r18, r28
     e92:	40 ec       	ldi	r20, 0xC0	; 192
     e94:	6a ef       	ldi	r22, 0xFA	; 250
     e96:	71 e0       	ldi	r23, 0x01	; 1
     e98:	80 e0       	ldi	r24, 0x00	; 0
     e9a:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>

	//==================================================================================
	
}
     e9e:	cf 91       	pop	r28
     ea0:	08 95       	ret

00000ea2 <display_eight>:
			 row position (LCD_SET_DDADR,LCD_SET_DDADR2), column position (LCD_COL0..LCD_COL16)

return: -
***************************************************************************************************/
void display_eight(uint8_t col)
{
     ea2:	cf 93       	push	r28
     ea4:	df 93       	push	r29
     ea6:	c8 2f       	mov	r28, r24
	
	
	//======================Number eight==================================================
	
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col);
     ea8:	28 2f       	mov	r18, r24
     eaa:	40 e8       	ldi	r20, 0x80	; 128
     eac:	6a ef       	ldi	r22, 0xFA	; 250
     eae:	71 e0       	ldi	r23, 0x01	; 1
     eb0:	80 e0       	ldi	r24, 0x00	; 0
     eb2:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col);
     eb6:	2c 2f       	mov	r18, r28
     eb8:	40 ec       	ldi	r20, 0xC0	; 192
     eba:	6a ef       	ldi	r22, 0xFA	; 250
     ebc:	71 e0       	ldi	r23, 0x01	; 1
     ebe:	80 e0       	ldi	r24, 0x00	; 0
     ec0:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR1, customChar1, LCD_SET_DDADR, col+1);
     ec4:	d1 e0       	ldi	r29, 0x01	; 1
     ec6:	dc 0f       	add	r29, r28
     ec8:	2d 2f       	mov	r18, r29
     eca:	40 e8       	ldi	r20, 0x80	; 128
     ecc:	62 ef       	ldi	r22, 0xF2	; 242
     ece:	71 e0       	ldi	r23, 0x01	; 1
     ed0:	81 e0       	ldi	r24, 0x01	; 1
     ed2:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col+2);
     ed6:	ce 5f       	subi	r28, 0xFE	; 254
     ed8:	2c 2f       	mov	r18, r28
     eda:	40 e8       	ldi	r20, 0x80	; 128
     edc:	6a ef       	ldi	r22, 0xFA	; 250
     ede:	71 e0       	ldi	r23, 0x01	; 1
     ee0:	80 e0       	ldi	r24, 0x00	; 0
     ee2:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col+2);
     ee6:	2c 2f       	mov	r18, r28
     ee8:	40 ec       	ldi	r20, 0xC0	; 192
     eea:	6a ef       	ldi	r22, 0xFA	; 250
     eec:	71 e0       	ldi	r23, 0x01	; 1
     eee:	80 e0       	ldi	r24, 0x00	; 0
     ef0:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR2, col+1);
     ef4:	2d 2f       	mov	r18, r29
     ef6:	40 ec       	ldi	r20, 0xC0	; 192
     ef8:	6a ee       	ldi	r22, 0xEA	; 234
     efa:	71 e0       	ldi	r23, 0x01	; 1
     efc:	82 e0       	ldi	r24, 0x02	; 2
     efe:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	//==================================================================================

	
}
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	08 95       	ret

00000f08 <display_nine>:
			 row position (LCD_SET_DDADR,LCD_SET_DDADR2), column position (LCD_COL0..LCD_COL16)

return: -
***************************************************************************************************/
void display_nine(uint8_t col)
{
     f08:	cf 93       	push	r28
     f0a:	c8 2f       	mov	r28, r24
	
	//======================Number nine==================================================
		
		lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col);
     f0c:	28 2f       	mov	r18, r24
     f0e:	40 e8       	ldi	r20, 0x80	; 128
     f10:	6a ef       	ldi	r22, 0xFA	; 250
     f12:	71 e0       	ldi	r23, 0x01	; 1
     f14:	80 e0       	ldi	r24, 0x00	; 0
     f16:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
		lcd_generatechar(LCD_GC_CHAR1, customChar1, LCD_SET_DDADR, col+1);
     f1a:	21 e0       	ldi	r18, 0x01	; 1
     f1c:	2c 0f       	add	r18, r28
     f1e:	40 e8       	ldi	r20, 0x80	; 128
     f20:	62 ef       	ldi	r22, 0xF2	; 242
     f22:	71 e0       	ldi	r23, 0x01	; 1
     f24:	81 e0       	ldi	r24, 0x01	; 1
     f26:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
		lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col+2);
     f2a:	ce 5f       	subi	r28, 0xFE	; 254
     f2c:	2c 2f       	mov	r18, r28
     f2e:	40 e8       	ldi	r20, 0x80	; 128
     f30:	6a ef       	ldi	r22, 0xFA	; 250
     f32:	71 e0       	ldi	r23, 0x01	; 1
     f34:	80 e0       	ldi	r24, 0x00	; 0
     f36:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
		lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col+2);
     f3a:	2c 2f       	mov	r18, r28
     f3c:	40 ec       	ldi	r20, 0xC0	; 192
     f3e:	6a ef       	ldi	r22, 0xFA	; 250
     f40:	71 e0       	ldi	r23, 0x01	; 1
     f42:	80 e0       	ldi	r24, 0x00	; 0
     f44:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	

	//==================================================================================

	
}
     f48:	cf 91       	pop	r28
     f4a:	08 95       	ret

00000f4c <display_zero>:
			 row position (LCD_SET_DDADR,LCD_SET_DDADR2), column position (LCD_COL0..LCD_COL16)

return: -
***************************************************************************************************/
void display_zero(uint8_t col)
{
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29
     f50:	c8 2f       	mov	r28, r24
	
	//======================Number zero==================================================
	
	
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col);
     f52:	28 2f       	mov	r18, r24
     f54:	40 e8       	ldi	r20, 0x80	; 128
     f56:	6a ef       	ldi	r22, 0xFA	; 250
     f58:	71 e0       	ldi	r23, 0x01	; 1
     f5a:	80 e0       	ldi	r24, 0x00	; 0
     f5c:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col);
     f60:	2c 2f       	mov	r18, r28
     f62:	40 ec       	ldi	r20, 0xC0	; 192
     f64:	6a ef       	ldi	r22, 0xFA	; 250
     f66:	71 e0       	ldi	r23, 0x01	; 1
     f68:	80 e0       	ldi	r24, 0x00	; 0
     f6a:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR3, customChar3, LCD_SET_DDADR, col+1);
     f6e:	d1 e0       	ldi	r29, 0x01	; 1
     f70:	dc 0f       	add	r29, r28
     f72:	2d 2f       	mov	r18, r29
     f74:	40 e8       	ldi	r20, 0x80	; 128
     f76:	62 ee       	ldi	r22, 0xE2	; 226
     f78:	71 e0       	ldi	r23, 0x01	; 1
     f7a:	83 e0       	ldi	r24, 0x03	; 3
     f7c:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR, col+2);
     f80:	ce 5f       	subi	r28, 0xFE	; 254
     f82:	2c 2f       	mov	r18, r28
     f84:	40 e8       	ldi	r20, 0x80	; 128
     f86:	6a ef       	ldi	r22, 0xFA	; 250
     f88:	71 e0       	ldi	r23, 0x01	; 1
     f8a:	80 e0       	ldi	r24, 0x00	; 0
     f8c:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR0, customChar0, LCD_SET_DDADR2, col+2);
     f90:	2c 2f       	mov	r18, r28
     f92:	40 ec       	ldi	r20, 0xC0	; 192
     f94:	6a ef       	ldi	r22, 0xFA	; 250
     f96:	71 e0       	ldi	r23, 0x01	; 1
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, customChar2, LCD_SET_DDADR2, col+1);
     f9e:	2d 2f       	mov	r18, r29
     fa0:	40 ec       	ldi	r20, 0xC0	; 192
     fa2:	6a ee       	ldi	r22, 0xEA	; 234
     fa4:	71 e0       	ldi	r23, 0x01	; 1
     fa6:	82 e0       	ldi	r24, 0x02	; 2
     fa8:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>


	//==================================================================================
	
	
}
     fac:	df 91       	pop	r29
     fae:	cf 91       	pop	r28
     fb0:	08 95       	ret

00000fb2 <display_dots>:
***************************************************************************************************/
void display_dots(void)
{
	

	lcd_generatechar(LCD_GC_CHAR4, customChar4, LCD_SET_DDADR, LCD_COL7);
     fb2:	27 e0       	ldi	r18, 0x07	; 7
     fb4:	40 e8       	ldi	r20, 0x80	; 128
     fb6:	6a ed       	ldi	r22, 0xDA	; 218
     fb8:	71 e0       	ldi	r23, 0x01	; 1
     fba:	84 e0       	ldi	r24, 0x04	; 4
     fbc:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR5, customChar5, LCD_SET_DDADR2, LCD_COL7);
     fc0:	27 e0       	ldi	r18, 0x07	; 7
     fc2:	40 ec       	ldi	r20, 0xC0	; 192
     fc4:	62 ed       	ldi	r22, 0xD2	; 210
     fc6:	71 e0       	ldi	r23, 0x01	; 1
     fc8:	85 e0       	ldi	r24, 0x05	; 5
     fca:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
     fce:	2f ef       	ldi	r18, 0xFF	; 255
     fd0:	87 e8       	ldi	r24, 0x87	; 135
     fd2:	93 e1       	ldi	r25, 0x13	; 19
     fd4:	21 50       	subi	r18, 0x01	; 1
     fd6:	80 40       	sbci	r24, 0x00	; 0
     fd8:	90 40       	sbci	r25, 0x00	; 0
     fda:	e1 f7       	brne	.-8      	; 0xfd4 <display_dots+0x22>
     fdc:	00 c0       	rjmp	.+0      	; 0xfde <display_dots+0x2c>
     fde:	00 00       	nop
	_delay_ms(400);
	lcd_setcursor(LCD_COL7, LCD_ROW1);
     fe0:	61 e0       	ldi	r22, 0x01	; 1
     fe2:	87 e0       	ldi	r24, 0x07	; 7
     fe4:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
	lcd_string(" ");
     fe8:	89 e8       	ldi	r24, 0x89	; 137
     fea:	91 e0       	ldi	r25, 0x01	; 1
     fec:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
	lcd_setcursor(LCD_COL7, LCD_ROW2);
     ff0:	62 e0       	ldi	r22, 0x02	; 2
     ff2:	87 e0       	ldi	r24, 0x07	; 7
     ff4:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
	lcd_string(" ");
     ff8:	89 e8       	ldi	r24, 0x89	; 137
     ffa:	91 e0       	ldi	r25, 0x01	; 1
     ffc:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
    1000:	2f ef       	ldi	r18, 0xFF	; 255
    1002:	87 e8       	ldi	r24, 0x87	; 135
    1004:	93 e1       	ldi	r25, 0x13	; 19
    1006:	21 50       	subi	r18, 0x01	; 1
    1008:	80 40       	sbci	r24, 0x00	; 0
    100a:	90 40       	sbci	r25, 0x00	; 0
    100c:	e1 f7       	brne	.-8      	; 0x1006 <display_dots+0x54>
    100e:	00 c0       	rjmp	.+0      	; 0x1010 <display_dots+0x5e>
    1010:	00 00       	nop
    1012:	08 95       	ret

00001014 <display_smalldots>:
***************************************************************************************************/

void display_smalldots(void)
{
	
	lcd_generatechar(LCD_GC_CHAR6, smalldots, LCD_SET_DDADR, LCD_COL4);
    1014:	24 e0       	ldi	r18, 0x04	; 4
    1016:	40 e8       	ldi	r20, 0x80	; 128
    1018:	62 eb       	ldi	r22, 0xB2	; 178
    101a:	71 e0       	ldi	r23, 0x01	; 1
    101c:	86 e0       	ldi	r24, 0x06	; 6
    101e:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
    1022:	2f ef       	ldi	r18, 0xFF	; 255
    1024:	87 e8       	ldi	r24, 0x87	; 135
    1026:	93 e1       	ldi	r25, 0x13	; 19
    1028:	21 50       	subi	r18, 0x01	; 1
    102a:	80 40       	sbci	r24, 0x00	; 0
    102c:	90 40       	sbci	r25, 0x00	; 0
    102e:	e1 f7       	brne	.-8      	; 0x1028 <display_smalldots+0x14>
    1030:	00 c0       	rjmp	.+0      	; 0x1032 <display_smalldots+0x1e>
    1032:	00 00       	nop
	_delay_ms(400);
	lcd_setcursor(LCD_COL4, LCD_ROW1);
    1034:	61 e0       	ldi	r22, 0x01	; 1
    1036:	84 e0       	ldi	r24, 0x04	; 4
    1038:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
	lcd_string(" ");
    103c:	89 e8       	ldi	r24, 0x89	; 137
    103e:	91 e0       	ldi	r25, 0x01	; 1
    1040:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
    1044:	2f ef       	ldi	r18, 0xFF	; 255
    1046:	87 e8       	ldi	r24, 0x87	; 135
    1048:	93 e1       	ldi	r25, 0x13	; 19
    104a:	21 50       	subi	r18, 0x01	; 1
    104c:	80 40       	sbci	r24, 0x00	; 0
    104e:	90 40       	sbci	r25, 0x00	; 0
    1050:	e1 f7       	brne	.-8      	; 0x104a <display_smalldots+0x36>
    1052:	00 c0       	rjmp	.+0      	; 0x1054 <display_smalldots+0x40>
    1054:	00 00       	nop
    1056:	08 95       	ret

00001058 <display_menu_bar>:
***************************************************************************************************/

void display_menu_bar(void)
{
	
	lcd_generatechar(LCD_GC_CHAR0, btchar, LCD_SET_DDADR2, LCD_COL1);
    1058:	21 e0       	ldi	r18, 0x01	; 1
    105a:	40 ec       	ldi	r20, 0xC0	; 192
    105c:	6a ea       	ldi	r22, 0xAA	; 170
    105e:	71 e0       	ldi	r23, 0x01	; 1
    1060:	80 e0       	ldi	r24, 0x00	; 0
    1062:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR1, clockchar, LCD_SET_DDADR2, LCD_COL7);
    1066:	27 e0       	ldi	r18, 0x07	; 7
    1068:	40 ec       	ldi	r20, 0xC0	; 192
    106a:	6a ec       	ldi	r22, 0xCA	; 202
    106c:	71 e0       	ldi	r23, 0x01	; 1
    106e:	81 e0       	ldi	r24, 0x01	; 1
    1070:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	lcd_generatechar(LCD_GC_CHAR2, tempchar, LCD_SET_DDADR2, LCD_COL13);
    1074:	2d e0       	ldi	r18, 0x0D	; 13
    1076:	40 ec       	ldi	r20, 0xC0	; 192
    1078:	62 ec       	ldi	r22, 0xC2	; 194
    107a:	71 e0       	ldi	r23, 0x01	; 1
    107c:	82 e0       	ldi	r24, 0x02	; 2
    107e:	0e 94 99 05 	call	0xb32	; 0xb32 <lcd_generatechar>
	


	
	if (dispclocktemp)
    1082:	80 91 2d 02 	lds	r24, 0x022D	; 0x80022d <dispclocktemp>
    1086:	88 23       	and	r24, r24
    1088:	81 f1       	breq	.+96     	; 0x10ea <display_menu_bar+0x92>
	{
			
		lcd_setcursor(LCD_COL0, LCD_ROW2);
    108a:	62 e0       	ldi	r22, 0x02	; 2
    108c:	80 e0       	ldi	r24, 0x00	; 0
    108e:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("[");
    1092:	89 e1       	ldi	r24, 0x19	; 25
    1094:	91 e0       	ldi	r25, 0x01	; 1
    1096:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL2, LCD_ROW2);
    109a:	62 e0       	ldi	r22, 0x02	; 2
    109c:	82 e0       	ldi	r24, 0x02	; 2
    109e:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("]");
    10a2:	8b e1       	ldi	r24, 0x1B	; 27
    10a4:	91 e0       	ldi	r25, 0x01	; 1
    10a6:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL6, LCD_ROW2);
    10aa:	62 e0       	ldi	r22, 0x02	; 2
    10ac:	86 e0       	ldi	r24, 0x06	; 6
    10ae:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("[");
    10b2:	89 e1       	ldi	r24, 0x19	; 25
    10b4:	91 e0       	ldi	r25, 0x01	; 1
    10b6:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL8, LCD_ROW2);
    10ba:	62 e0       	ldi	r22, 0x02	; 2
    10bc:	88 e0       	ldi	r24, 0x08	; 8
    10be:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("]");
    10c2:	8b e1       	ldi	r24, 0x1B	; 27
    10c4:	91 e0       	ldi	r25, 0x01	; 1
    10c6:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL12, LCD_ROW2);
    10ca:	62 e0       	ldi	r22, 0x02	; 2
    10cc:	8c e0       	ldi	r24, 0x0C	; 12
    10ce:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string(">");
    10d2:	8b e0       	ldi	r24, 0x0B	; 11
    10d4:	91 e0       	ldi	r25, 0x01	; 1
    10d6:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL14, LCD_ROW2);
    10da:	62 e0       	ldi	r22, 0x02	; 2
    10dc:	8e e0       	ldi	r24, 0x0E	; 14
    10de:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("<");
    10e2:	8d e0       	ldi	r24, 0x0D	; 13
    10e4:	91 e0       	ldi	r25, 0x01	; 1
    10e6:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
				
			
	}
	
	if (dispbluetooth)
    10ea:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <dispbluetooth>
    10ee:	88 23       	and	r24, r24
    10f0:	81 f1       	breq	.+96     	; 0x1152 <display_menu_bar+0xfa>
	{
			
		lcd_setcursor(LCD_COL0, LCD_ROW2);
    10f2:	62 e0       	ldi	r22, 0x02	; 2
    10f4:	80 e0       	ldi	r24, 0x00	; 0
    10f6:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string(">");
    10fa:	8b e0       	ldi	r24, 0x0B	; 11
    10fc:	91 e0       	ldi	r25, 0x01	; 1
    10fe:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL2, LCD_ROW2);
    1102:	62 e0       	ldi	r22, 0x02	; 2
    1104:	82 e0       	ldi	r24, 0x02	; 2
    1106:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("<");
    110a:	8d e0       	ldi	r24, 0x0D	; 13
    110c:	91 e0       	ldi	r25, 0x01	; 1
    110e:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL6, LCD_ROW2);
    1112:	62 e0       	ldi	r22, 0x02	; 2
    1114:	86 e0       	ldi	r24, 0x06	; 6
    1116:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("[");
    111a:	89 e1       	ldi	r24, 0x19	; 25
    111c:	91 e0       	ldi	r25, 0x01	; 1
    111e:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL8, LCD_ROW2);
    1122:	62 e0       	ldi	r22, 0x02	; 2
    1124:	88 e0       	ldi	r24, 0x08	; 8
    1126:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("]");
    112a:	8b e1       	ldi	r24, 0x1B	; 27
    112c:	91 e0       	ldi	r25, 0x01	; 1
    112e:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL12, LCD_ROW2);
    1132:	62 e0       	ldi	r22, 0x02	; 2
    1134:	8c e0       	ldi	r24, 0x0C	; 12
    1136:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("[");
    113a:	89 e1       	ldi	r24, 0x19	; 25
    113c:	91 e0       	ldi	r25, 0x01	; 1
    113e:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
		lcd_setcursor(LCD_COL14, LCD_ROW2);
    1142:	62 e0       	ldi	r22, 0x02	; 2
    1144:	8e e0       	ldi	r24, 0x0E	; 14
    1146:	0e 94 7d 05 	call	0xafa	; 0xafa <lcd_setcursor>
		lcd_string("]");
    114a:	8b e1       	ldi	r24, 0x1B	; 27
    114c:	91 e0       	ldi	r25, 0x01	; 1
    114e:	0e 94 64 05 	call	0xac8	; 0xac8 <lcd_string>
    1152:	08 95       	ret

00001154 <init>:
/* Initialization functions  */
/****************************/
void init(void)
{
	
	lcd_Init();						//LCD initialization
    1154:	0e 94 cd 05 	call	0xb9a	; 0xb9a <lcd_Init>
	TWI_Master_Init();				//Twi Master initialization
    1158:	0e 94 a8 09 	call	0x1350	; 0x1350 <TWI_Master_Init>
	buttons_Init();					//Buttons initialization
    115c:	0e 94 0f 03 	call	0x61e	; 0x61e <buttons_Init>
	usart_Init();					//USART initialization
    1160:	0e 94 ca 02 	call	0x594	; 0x594 <usart_Init>
	init_bluetooth();				//Bluetooth module initialization
    1164:	0e 94 b8 00 	call	0x170	; 0x170 <init_bluetooth>
    1168:	08 95       	ret

0000116a <main>:
	

int main (void)
{
	
	init();							//Initialization functions
    116a:	0e 94 aa 08 	call	0x1154	; 0x1154 <init>
	
	//display_Loading();				//Displays intro 

	
	//rtc_set_time(58,03,11);		   //Set time, secs, mins, hours
	lcd_home();
    116e:	0e 94 73 05 	call	0xae6	; 0xae6 <lcd_home>
	sei();							//Enable interrupts
    1172:	78 94       	sei

	while(1) 
	{
			
			
			rtc_read_time();
    1174:	0e 94 55 09 	call	0x12aa	; 0x12aa <rtc_read_time>
			rtc_read_temp();
    1178:	0e 94 86 09 	call	0x130c	; 0x130c <rtc_read_temp>
			
			if (dispclock)
    117c:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <dispclock>
    1180:	88 23       	and	r24, r24
    1182:	91 f0       	breq	.+36     	; 0x11a8 <main+0x3e>
			{
				
			 if (sec == 0 || showclockonetime == 1)
    1184:	80 91 2f 02 	lds	r24, 0x022F	; 0x80022f <sec>
    1188:	88 23       	and	r24, r24
    118a:	21 f0       	breq	.+8      	; 0x1194 <main+0x2a>
    118c:	80 91 51 02 	lds	r24, 0x0251	; 0x800251 <showclockonetime>
    1190:	81 30       	cpi	r24, 0x01	; 1
    1192:	41 f4       	brne	.+16     	; 0x11a4 <main+0x3a>
				{
			
					display_clock(hour, min);
    1194:	60 91 2e 02 	lds	r22, 0x022E	; 0x80022e <min>
    1198:	80 91 1e 02 	lds	r24, 0x021E	; 0x80021e <hour>
    119c:	0e 94 3e 04 	call	0x87c	; 0x87c <display_clock>
					showclockonetime = FALSE;
    11a0:	10 92 51 02 	sts	0x0251, r1	; 0x800251 <showclockonetime>
						
				}
				
				display_dots();
    11a4:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <display_dots>
					
			}
			
	
				
			if (dispclocktemp)
    11a8:	80 91 2d 02 	lds	r24, 0x022D	; 0x80022d <dispclocktemp>
    11ac:	88 23       	and	r24, r24
    11ae:	b1 f0       	breq	.+44     	; 0x11dc <main+0x72>
			{
					
					if (sec == 0 || showclockonetime == 1)
    11b0:	80 91 2f 02 	lds	r24, 0x022F	; 0x80022f <sec>
    11b4:	88 23       	and	r24, r24
    11b6:	21 f0       	breq	.+8      	; 0x11c0 <main+0x56>
    11b8:	80 91 51 02 	lds	r24, 0x0251	; 0x800251 <showclockonetime>
    11bc:	81 30       	cpi	r24, 0x01	; 1
    11be:	61 f4       	brne	.+24     	; 0x11d8 <main+0x6e>
					{
					   
					   display_menu_bar();	 
    11c0:	0e 94 2c 08 	call	0x1058	; 0x1058 <display_menu_bar>
					   display_clocktemp(hour, min, temperature);
    11c4:	40 91 09 02 	lds	r20, 0x0209	; 0x800209 <temperature>
    11c8:	60 91 2e 02 	lds	r22, 0x022E	; 0x80022e <min>
    11cc:	80 91 1e 02 	lds	r24, 0x021E	; 0x80021e <hour>
    11d0:	0e 94 ae 04 	call	0x95c	; 0x95c <display_clocktemp>
					   showclockonetime = FALSE;
    11d4:	10 92 51 02 	sts	0x0251, r1	; 0x800251 <showclockonetime>
							 
					}
						 
						 display_smalldots();
    11d8:	0e 94 0a 08 	call	0x1014	; 0x1014 <display_smalldots>
				}
				
			if (dispbluetooth)
    11dc:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <dispbluetooth>
    11e0:	88 23       	and	r24, r24
    11e2:	41 f2       	breq	.-112    	; 0x1174 <main+0xa>
			{
				
					connectingBlueTooth();
    11e4:	0e 94 bc 00 	call	0x178	; 0x178 <connectingBlueTooth>
					if (connectedflag == TRUE)
    11e8:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <__data_end>
    11ec:	81 30       	cpi	r24, 0x01	; 1
    11ee:	11 f6       	brne	.-124    	; 0x1174 <main+0xa>
					{
						bluetoothMenu(usart_recieve());
    11f0:	0e 94 d6 02 	call	0x5ac	; 0x5ac <usart_recieve>
    11f4:	0e 94 67 02 	call	0x4ce	; 0x4ce <bluetoothMenu>
    11f8:	bd cf       	rjmp	.-134    	; 0x1174 <main+0xa>

000011fa <dec2bcd>:
/* Decimal to BCD converter                                             */
/************************************************************************/
uint8_t dec2bcd(uint8_t dec)
{

	return (((dec / 10) << 4) | (dec % 10));	
    11fa:	9d ec       	ldi	r25, 0xCD	; 205
    11fc:	89 9f       	mul	r24, r25
    11fe:	91 2d       	mov	r25, r1
    1200:	11 24       	eor	r1, r1
    1202:	96 95       	lsr	r25
    1204:	96 95       	lsr	r25
    1206:	96 95       	lsr	r25
    1208:	20 e1       	ldi	r18, 0x10	; 16
    120a:	92 9f       	mul	r25, r18
    120c:	a0 01       	movw	r20, r0
    120e:	11 24       	eor	r1, r1
    1210:	99 0f       	add	r25, r25
    1212:	29 2f       	mov	r18, r25
    1214:	22 0f       	add	r18, r18
    1216:	22 0f       	add	r18, r18
    1218:	92 0f       	add	r25, r18
    121a:	89 1b       	sub	r24, r25

}
    121c:	84 2b       	or	r24, r20
    121e:	08 95       	ret

00001220 <bcd2dec>:
/*BCD to decimal converter                                             */
/************************************************************************/
uint8_t bcd2dec(uint8_t bcd)
{
	
	return(((bcd & 0xF0) >> 4) * 10) + (bcd & 0x0F);
    1220:	98 2f       	mov	r25, r24
    1222:	92 95       	swap	r25
    1224:	9f 70       	andi	r25, 0x0F	; 15
    1226:	99 0f       	add	r25, r25
    1228:	29 2f       	mov	r18, r25
    122a:	22 0f       	add	r18, r18
    122c:	22 0f       	add	r18, r18
    122e:	92 0f       	add	r25, r18
    1230:	8f 70       	andi	r24, 0x0F	; 15
}
    1232:	89 0f       	add	r24, r25
    1234:	08 95       	ret

00001236 <rtc_set_time>:

/************************************************************************/
/* Sets the time and date for the RTC                          */
/************************************************************************/
void rtc_set_time(uint8_t seconds, uint8_t min, uint8_t hour)
{
    1236:	0f 93       	push	r16
    1238:	1f 93       	push	r17
    123a:	cf 93       	push	r28
    123c:	df 93       	push	r29
    123e:	00 d0       	rcall	.+0      	; 0x1240 <rtc_set_time+0xa>
    1240:	00 d0       	rcall	.+0      	; 0x1242 <rtc_set_time+0xc>
    1242:	1f 92       	push	r1
    1244:	cd b7       	in	r28, 0x3d	; 61
    1246:	de b7       	in	r29, 0x3e	; 62
    1248:	06 2f       	mov	r16, r22
    124a:	14 2f       	mov	r17, r20
	uint8_t timearray[5];					//Time buffer;
	uint8_t regpointer = SECONDS;			//Initial address register for the RTC
	
	timearray[0] = SLA_ADD_W;				//Write command for the TWI interface
    124c:	90 ed       	ldi	r25, 0xD0	; 208
    124e:	99 83       	std	Y+1, r25	; 0x01
	timearray[1] = regpointer;				//Pointer to the register in RTC
    1250:	1a 82       	std	Y+2, r1	; 0x02
	timearray[2] = dec2bcd(seconds);		//Decimal to bcd converter seconds
    1252:	0e 94 fd 08 	call	0x11fa	; 0x11fa <dec2bcd>
    1256:	8b 83       	std	Y+3, r24	; 0x03
	timearray[3] = dec2bcd(min);			//..minutes
    1258:	80 2f       	mov	r24, r16
    125a:	0e 94 fd 08 	call	0x11fa	; 0x11fa <dec2bcd>
    125e:	8c 83       	std	Y+4, r24	; 0x04
	timearray[4] = dec2bcd(hour);			//..hours
    1260:	81 2f       	mov	r24, r17
    1262:	0e 94 fd 08 	call	0x11fa	; 0x11fa <dec2bcd>
    1266:	8d 83       	std	Y+5, r24	; 0x05
	
	TWI_Transmit_Data(timearray, 5);		//Write the time to RTC registers		
    1268:	65 e0       	ldi	r22, 0x05	; 5
    126a:	ce 01       	movw	r24, r28
    126c:	01 96       	adiw	r24, 0x01	; 1
    126e:	0e 94 b3 09 	call	0x1366	; 0x1366 <TWI_Transmit_Data>
	

}
    1272:	0f 90       	pop	r0
    1274:	0f 90       	pop	r0
    1276:	0f 90       	pop	r0
    1278:	0f 90       	pop	r0
    127a:	0f 90       	pop	r0
    127c:	df 91       	pop	r29
    127e:	cf 91       	pop	r28
    1280:	1f 91       	pop	r17
    1282:	0f 91       	pop	r16
    1284:	08 95       	ret

00001286 <rtc_set_regpoint>:

/************************************************************************/
/* Set the register point to a certain address on the RTC		         */
/************************************************************************/
void rtc_set_regpoint(uint8_t regpoint)
{
    1286:	cf 93       	push	r28
    1288:	df 93       	push	r29
    128a:	00 d0       	rcall	.+0      	; 0x128c <rtc_set_regpoint+0x6>
    128c:	cd b7       	in	r28, 0x3d	; 61
    128e:	de b7       	in	r29, 0x3e	; 62
	uint8_t regpointarray[2];					//Register pointer buffer
	
	regpointarray[0] = SLA_ADD_W;				//Store write command
    1290:	90 ed       	ldi	r25, 0xD0	; 208
    1292:	99 83       	std	Y+1, r25	; 0x01
	regpointarray[1] = regpoint;				//Store the pointer address
    1294:	8a 83       	std	Y+2, r24	; 0x02
			
	
	TWI_Transmit_Data(regpointarray, 2);		//set the reg pointer to the address
    1296:	62 e0       	ldi	r22, 0x02	; 2
    1298:	ce 01       	movw	r24, r28
    129a:	01 96       	adiw	r24, 0x01	; 1
    129c:	0e 94 b3 09 	call	0x1366	; 0x1366 <TWI_Transmit_Data>
	
		
}
    12a0:	0f 90       	pop	r0
    12a2:	0f 90       	pop	r0
    12a4:	df 91       	pop	r29
    12a6:	cf 91       	pop	r28
    12a8:	08 95       	ret

000012aa <rtc_read_time>:

/************************************************************************/
/* Reads the time from the RTC                                          */
/************************************************************************/
void rtc_read_time(void)
{
    12aa:	cf 93       	push	r28
    12ac:	df 93       	push	r29
    12ae:	cd b7       	in	r28, 0x3d	; 61
    12b0:	de b7       	in	r29, 0x3e	; 62
    12b2:	2c 97       	sbiw	r28, 0x0c	; 12
    12b4:	0f b6       	in	r0, 0x3f	; 63
    12b6:	f8 94       	cli
    12b8:	de bf       	out	0x3e, r29	; 62
    12ba:	0f be       	out	0x3f, r0	; 63
    12bc:	cd bf       	out	0x3d, r28	; 61
	
	uint8_t buff1[6];							//Prepare buffer to send
	uint8_t buff2[6];							//Prepare buffer to receive
	
	buff1[0]=SLA_ADD_R;							//Store Read command in write buffer
    12be:	81 ed       	ldi	r24, 0xD1	; 209
    12c0:	89 83       	std	Y+1, r24	; 0x01
	TWI_Transmit_Data(buff1, 6);				//Send the read command and receive data
    12c2:	66 e0       	ldi	r22, 0x06	; 6
    12c4:	ce 01       	movw	r24, r28
    12c6:	01 96       	adiw	r24, 0x01	; 1
    12c8:	0e 94 b3 09 	call	0x1366	; 0x1366 <TWI_Transmit_Data>
	TWI_Get_Data(buff2, 6);						//Get the data received in TWI operation
    12cc:	66 e0       	ldi	r22, 0x06	; 6
    12ce:	ce 01       	movw	r24, r28
    12d0:	07 96       	adiw	r24, 0x07	; 7
    12d2:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <TWI_Get_Data>
	sec = bcd2dec(buff2[3]);					//Get seconds
    12d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    12d8:	0e 94 10 09 	call	0x1220	; 0x1220 <bcd2dec>
    12dc:	80 93 2f 02 	sts	0x022F, r24	; 0x80022f <sec>
	min = bcd2dec(buff2[4]);					//Get minutes
    12e0:	8b 85       	ldd	r24, Y+11	; 0x0b
    12e2:	0e 94 10 09 	call	0x1220	; 0x1220 <bcd2dec>
    12e6:	80 93 2e 02 	sts	0x022E, r24	; 0x80022e <min>
	hour = bcd2dec(buff2[5]);					//Get hours
    12ea:	8c 85       	ldd	r24, Y+12	; 0x0c
    12ec:	0e 94 10 09 	call	0x1220	; 0x1220 <bcd2dec>
    12f0:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <hour>
	
	rtc_set_regpoint(SECONDS);					//Set register point in RTC
    12f4:	80 e0       	ldi	r24, 0x00	; 0
    12f6:	0e 94 43 09 	call	0x1286	; 0x1286 <rtc_set_regpoint>
	
	
		
	
}
    12fa:	2c 96       	adiw	r28, 0x0c	; 12
    12fc:	0f b6       	in	r0, 0x3f	; 63
    12fe:	f8 94       	cli
    1300:	de bf       	out	0x3e, r29	; 62
    1302:	0f be       	out	0x3f, r0	; 63
    1304:	cd bf       	out	0x3d, r28	; 61
    1306:	df 91       	pop	r29
    1308:	cf 91       	pop	r28
    130a:	08 95       	ret

0000130c <rtc_read_temp>:
/************************************************************************/
/* Reads the temperature on the RTC										*/
/************************************************************************/

void rtc_read_temp(void)
{
    130c:	cf 93       	push	r28
    130e:	df 93       	push	r29
    1310:	00 d0       	rcall	.+0      	; 0x1312 <rtc_read_temp+0x6>
    1312:	00 d0       	rcall	.+0      	; 0x1314 <rtc_read_temp+0x8>
    1314:	00 d0       	rcall	.+0      	; 0x1316 <rtc_read_temp+0xa>
    1316:	cd b7       	in	r28, 0x3d	; 61
    1318:	de b7       	in	r29, 0x3e	; 62
	uint8_t buff1[3];						//Prepare buffer
	uint8_t buff2[3];						//...
	
	rtc_set_regpoint(RTCTEMP1);				//Set pointer at temperature register	
    131a:	81 e1       	ldi	r24, 0x11	; 17
    131c:	0e 94 43 09 	call	0x1286	; 0x1286 <rtc_set_regpoint>
	
	buff1[0]=SLA_ADD_R;						//Store Read command at read buffer
    1320:	81 ed       	ldi	r24, 0xD1	; 209
    1322:	89 83       	std	Y+1, r24	; 0x01
	TWI_Transmit_Data(buff1, 3);			//Transmit and receive data
    1324:	63 e0       	ldi	r22, 0x03	; 3
    1326:	ce 01       	movw	r24, r28
    1328:	01 96       	adiw	r24, 0x01	; 1
    132a:	0e 94 b3 09 	call	0x1366	; 0x1366 <TWI_Transmit_Data>
	TWI_Get_Data(buff2, 3);					//Get the data received
    132e:	63 e0       	ldi	r22, 0x03	; 3
    1330:	ce 01       	movw	r24, r28
    1332:	04 96       	adiw	r24, 0x04	; 4
    1334:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <TWI_Get_Data>
	temperature = buff2[2];					//Store the temperature data in variable
    1338:	8e 81       	ldd	r24, Y+6	; 0x06
    133a:	80 93 09 02 	sts	0x0209, r24	; 0x800209 <temperature>
	
	

}
    133e:	26 96       	adiw	r28, 0x06	; 6
    1340:	0f b6       	in	r0, 0x3f	; 63
    1342:	f8 94       	cli
    1344:	de bf       	out	0x3e, r29	; 62
    1346:	0f be       	out	0x3f, r0	; 63
    1348:	cd bf       	out	0x3d, r28	; 61
    134a:	df 91       	pop	r29
    134c:	cf 91       	pop	r28
    134e:	08 95       	ret

00001350 <TWI_Master_Init>:
uint8_t TWI_State_Info (void)
{
	while(TWI_Is_Busy());
	
	return TWI_State;
}
    1350:	8c e0       	ldi	r24, 0x0C	; 12
    1352:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    1356:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    135a:	84 e0       	ldi	r24, 0x04	; 4
    135c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1360:	10 92 44 02 	sts	0x0244, r1	; 0x800244 <TWIOpInfo>
    1364:	08 95       	ret

00001366 <TWI_Transmit_Data>:
    1366:	cf 93       	push	r28
    1368:	df 93       	push	r29
    136a:	ec 01       	movw	r28, r24
    136c:	60 93 2c 02 	sts	0x022C, r22	; 0x80022c <Rx_Buff_Len>
    1370:	60 93 52 02 	sts	0x0252, r22	; 0x800252 <Tx_Buff_len>
    1374:	88 ef       	ldi	r24, 0xF8	; 248
    1376:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <TWI_State>
    137a:	64 31       	cpi	r22, 0x14	; 20
    137c:	10 f5       	brcc	.+68     	; 0x13c2 <TWI_Transmit_Data+0x5c>
    137e:	ec eb       	ldi	r30, 0xBC	; 188
    1380:	f0 e0       	ldi	r31, 0x00	; 0
    1382:	90 81       	ld	r25, Z
    1384:	90 fd       	sbrc	r25, 0
    1386:	fd cf       	rjmp	.-6      	; 0x1382 <TWI_Transmit_Data+0x1c>
    1388:	88 81       	ld	r24, Y
    138a:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <TWI_Tx_Buff>
    138e:	88 81       	ld	r24, Y
    1390:	80 3d       	cpi	r24, 0xD0	; 208
    1392:	99 f4       	brne	.+38     	; 0x13ba <TWI_Transmit_Data+0x54>
    1394:	62 30       	cpi	r22, 0x02	; 2
    1396:	88 f0       	brcs	.+34     	; 0x13ba <TWI_Transmit_Data+0x54>
    1398:	fe 01       	movw	r30, r28
    139a:	31 96       	adiw	r30, 0x01	; 1
    139c:	ab e0       	ldi	r26, 0x0B	; 11
    139e:	b2 e0       	ldi	r27, 0x02	; 2
    13a0:	62 50       	subi	r22, 0x02	; 2
    13a2:	26 2f       	mov	r18, r22
    13a4:	30 e0       	ldi	r19, 0x00	; 0
    13a6:	2e 5f       	subi	r18, 0xFE	; 254
    13a8:	3f 4f       	sbci	r19, 0xFF	; 255
    13aa:	ce 01       	movw	r24, r28
    13ac:	82 0f       	add	r24, r18
    13ae:	93 1f       	adc	r25, r19
    13b0:	21 91       	ld	r18, Z+
    13b2:	2d 93       	st	X+, r18
    13b4:	e8 17       	cp	r30, r24
    13b6:	f9 07       	cpc	r31, r25
    13b8:	d9 f7       	brne	.-10     	; 0x13b0 <TWI_Transmit_Data+0x4a>
    13ba:	85 ea       	ldi	r24, 0xA5	; 165
    13bc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    13c0:	03 c0       	rjmp	.+6      	; 0x13c8 <TWI_Transmit_Data+0x62>
    13c2:	81 e0       	ldi	r24, 0x01	; 1
    13c4:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <TWI_State>
    13c8:	10 92 44 02 	sts	0x0244, r1	; 0x800244 <TWIOpInfo>
    13cc:	df 91       	pop	r29
    13ce:	cf 91       	pop	r28
    13d0:	08 95       	ret

000013d2 <TWI_Get_Data>:
    13d2:	ac 01       	movw	r20, r24
    13d4:	ec eb       	ldi	r30, 0xBC	; 188
    13d6:	f0 e0       	ldi	r31, 0x00	; 0
    13d8:	90 81       	ld	r25, Z
    13da:	90 fd       	sbrc	r25, 0
    13dc:	fd cf       	rjmp	.-6      	; 0x13d8 <TWI_Get_Data+0x6>
    13de:	80 91 44 02 	lds	r24, 0x0244	; 0x800244 <TWIOpInfo>
    13e2:	88 23       	and	r24, r24
    13e4:	89 f0       	breq	.+34     	; 0x1408 <TWI_Get_Data+0x36>
    13e6:	66 23       	and	r22, r22
    13e8:	79 f0       	breq	.+30     	; 0x1408 <TWI_Get_Data+0x36>
    13ea:	a0 e3       	ldi	r26, 0x30	; 48
    13ec:	b2 e0       	ldi	r27, 0x02	; 2
    13ee:	fa 01       	movw	r30, r20
    13f0:	61 50       	subi	r22, 0x01	; 1
    13f2:	26 2f       	mov	r18, r22
    13f4:	30 e0       	ldi	r19, 0x00	; 0
    13f6:	2f 5f       	subi	r18, 0xFF	; 255
    13f8:	3f 4f       	sbci	r19, 0xFF	; 255
    13fa:	24 0f       	add	r18, r20
    13fc:	35 1f       	adc	r19, r21
    13fe:	9d 91       	ld	r25, X+
    1400:	91 93       	st	Z+, r25
    1402:	e2 17       	cp	r30, r18
    1404:	f3 07       	cpc	r31, r19
    1406:	d9 f7       	brne	.-10     	; 0x13fe <TWI_Get_Data+0x2c>
    1408:	80 91 44 02 	lds	r24, 0x0244	; 0x800244 <TWIOpInfo>
    140c:	08 95       	ret

0000140e <__vector_24>:

/************************************************************************/
/* Interrupt vector function for the TWI-Op                             */
/************************************************************************/
ISR (TWI_vect)
{
    140e:	1f 92       	push	r1
    1410:	0f 92       	push	r0
    1412:	0f b6       	in	r0, 0x3f	; 63
    1414:	0f 92       	push	r0
    1416:	11 24       	eor	r1, r1
    1418:	2f 93       	push	r18
    141a:	3f 93       	push	r19
    141c:	8f 93       	push	r24
    141e:	9f 93       	push	r25
    1420:	af 93       	push	r26
    1422:	bf 93       	push	r27
    1424:	ef 93       	push	r30
    1426:	ff 93       	push	r31
	
	switch(TWSR)										//Check the status code for the TWSR
    1428:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    142c:	8e 2f       	mov	r24, r30
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	fc 01       	movw	r30, r24
    1432:	38 97       	sbiw	r30, 0x08	; 8
    1434:	e1 35       	cpi	r30, 0x51	; 81
    1436:	f1 05       	cpc	r31, r1
    1438:	08 f0       	brcs	.+2      	; 0x143c <__vector_24+0x2e>
    143a:	50 c0       	rjmp	.+160    	; 0x14dc <__vector_24+0xce>
    143c:	e8 5b       	subi	r30, 0xB8	; 184
    143e:	ff 4f       	sbci	r31, 0xFF	; 255
    1440:	0c 94 82 0a 	jmp	0x1504	; 0x1504 <__tablejump2__>
	{
		case TWI_START:									//Start condition has been sent code: 0x08
			
		case TWI_REP_START:								//Repeat start has been sent code:0x10
			 
			 TWI_Buff_Pt = 0;							//Set/Reset the pointer	
    1444:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <TWI_Buff_Pt>
				 
		case TWI_MTX_ADR_ACK:							//Slave + W has been sent and ACK received code:0x18
		
		case TWI_MTX_DATA_ACK:							//Data byte has been transmitted and ACK received code:0x28
		
			if (TWI_Buff_Pt < Tx_Buff_len )
    1448:	e0 91 04 02 	lds	r30, 0x0204	; 0x800204 <TWI_Buff_Pt>
    144c:	80 91 52 02 	lds	r24, 0x0252	; 0x800252 <Tx_Buff_len>
    1450:	e8 17       	cp	r30, r24
    1452:	70 f4       	brcc	.+28     	; 0x1470 <__vector_24+0x62>
			{
				
				TWDR = TWI_Tx_Buff[TWI_Buff_Pt++];
    1454:	81 e0       	ldi	r24, 0x01	; 1
    1456:	8e 0f       	add	r24, r30
    1458:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <TWI_Buff_Pt>
    145c:	f0 e0       	ldi	r31, 0x00	; 0
    145e:	e6 5f       	subi	r30, 0xF6	; 246
    1460:	fd 4f       	sbci	r31, 0xFD	; 253
    1462:	80 81       	ld	r24, Z
    1464:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
				TWISendTransmit();						//Send the byte loaded into the TWDR
    1468:	85 e8       	ldi	r24, 0x85	; 133
    146a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    146e:	3d c0       	rjmp	.+122    	; 0x14ea <__vector_24+0xdc>
				
			}
			
			else
			{
				TWIOpInfo.LastOperationOK = TRUE;		//Last operation went OK
    1470:	81 e0       	ldi	r24, 0x01	; 1
    1472:	80 93 44 02 	sts	0x0244, r24	; 0x800244 <TWIOpInfo>
				TWISendStop();							//Last byte has been sent, stop operation
    1476:	84 e9       	ldi	r24, 0x94	; 148
    1478:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    147c:	36 c0       	rjmp	.+108    	; 0x14ea <__vector_24+0xdc>
			
		case TWI_MRX_ADR_ACK:						    //SLA + R byte received ACK sent
			
		case TWI_MRX_DATA_ACK:						    //Data byte received ACK sent
		
			TWI_Rx_Buff[TWI_Buff_Pt++] = TWDR;			//Store the data received to TWI receive buffer	
    147e:	e0 91 04 02 	lds	r30, 0x0204	; 0x800204 <TWI_Buff_Pt>
    1482:	21 e0       	ldi	r18, 0x01	; 1
    1484:	2e 0f       	add	r18, r30
    1486:	20 93 04 02 	sts	0x0204, r18	; 0x800204 <TWI_Buff_Pt>
    148a:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    148e:	f0 e0       	ldi	r31, 0x00	; 0
    1490:	e0 5d       	subi	r30, 0xD0	; 208
    1492:	fd 4f       	sbci	r31, 0xFD	; 253
    1494:	80 83       	st	Z, r24
			
			
			if (TWI_Buff_Pt < (Rx_Buff_Len - 1 ))		//As long as it is not the last one byte to receive send an ACK
    1496:	30 e0       	ldi	r19, 0x00	; 0
    1498:	80 91 2c 02 	lds	r24, 0x022C	; 0x80022c <Rx_Buff_Len>
    149c:	90 e0       	ldi	r25, 0x00	; 0
    149e:	01 97       	sbiw	r24, 0x01	; 1
    14a0:	28 17       	cp	r18, r24
    14a2:	39 07       	cpc	r19, r25
    14a4:	24 f4       	brge	.+8      	; 0x14ae <__vector_24+0xa0>
			{
				
				TWISendACK();
    14a6:	85 ec       	ldi	r24, 0xC5	; 197
    14a8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    14ac:	1e c0       	rjmp	.+60     	; 0x14ea <__vector_24+0xdc>
			}
			 
			else										// If it is the last byte send an NACK
			{
		
				TWISendNACK();
    14ae:	85 e8       	ldi	r24, 0x85	; 133
    14b0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    14b4:	1a c0       	rjmp	.+52     	; 0x14ea <__vector_24+0xdc>
			}
			break;
		
		case TWI_MRX_DATA_NACK:							//Data byte has been received NACK transmitted code:0x58
			
			TWI_Rx_Buff[TWI_Buff_Pt] = TWDR;			//Receive the last byte cause NACK has been transmitted
    14b6:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    14ba:	e0 91 04 02 	lds	r30, 0x0204	; 0x800204 <TWI_Buff_Pt>
    14be:	f0 e0       	ldi	r31, 0x00	; 0
    14c0:	e0 5d       	subi	r30, 0xD0	; 208
    14c2:	fd 4f       	sbci	r31, 0xFD	; 253
    14c4:	80 83       	st	Z, r24
			
			TWIOpInfo.LastOperationOK = TRUE;		    //Last operation went OK
    14c6:	81 e0       	ldi	r24, 0x01	; 1
    14c8:	80 93 44 02 	sts	0x0244, r24	; 0x800244 <TWIOpInfo>
			TWISendStop();								//Stop operation
    14cc:	84 e9       	ldi	r24, 0x94	; 148
    14ce:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
			
			break;
    14d2:	0b c0       	rjmp	.+22     	; 0x14ea <__vector_24+0xdc>
			
		case TWI_ARB_LOST:								//Arbitration lost, restart operation
		
			 TWISendStart();
    14d4:	85 ea       	ldi	r24, 0xA5	; 165
    14d6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
			 
			 break;
    14da:	07 c0       	rjmp	.+14     	; 0x14ea <__vector_24+0xdc>
		
		case TWI_BUS_ERROR:								//TWI Bus error code: 0x00
		
		default:										
			
			TWI_State = TWSR;							//Store the error-state code
    14dc:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    14e0:	80 93 05 02 	sts	0x0205, r24	; 0x800205 <TWI_State>
			TWIReset();									//Reset the TWI interface
    14e4:	84 e8       	ldi	r24, 0x84	; 132
    14e6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
			
	}
	
    14ea:	ff 91       	pop	r31
    14ec:	ef 91       	pop	r30
    14ee:	bf 91       	pop	r27
    14f0:	af 91       	pop	r26
    14f2:	9f 91       	pop	r25
    14f4:	8f 91       	pop	r24
    14f6:	3f 91       	pop	r19
    14f8:	2f 91       	pop	r18
    14fa:	0f 90       	pop	r0
    14fc:	0f be       	out	0x3f, r0	; 63
    14fe:	0f 90       	pop	r0
    1500:	1f 90       	pop	r1
    1502:	18 95       	reti

00001504 <__tablejump2__>:
    1504:	ee 0f       	add	r30, r30
    1506:	ff 1f       	adc	r31, r31
    1508:	05 90       	lpm	r0, Z+
    150a:	f4 91       	lpm	r31, Z
    150c:	e0 2d       	mov	r30, r0
    150e:	09 94       	ijmp

00001510 <_exit>:
    1510:	f8 94       	cli

00001512 <__stop_program>:
    1512:	ff cf       	rjmp	.-2      	; 0x1512 <__stop_program>
